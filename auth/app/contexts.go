// Code generated by goagen v1.3.1, DO NOT EDIT.
//
// API "user": Application Contexts
//
// Command:
// $ goagen
// --design=gigglesearch.org/giggle-auth/auth/design
// --out=$(GOPATH)/src/gigglesearch.org/giggle-auth/auth
// --version=v1.3.1

package app

import (
	"context"
	"github.com/goadesign/goa"
	uuid "github.com/gofrs/uuid"
	"net/http"
	"strconv"
)

// AttachToAccountAmazonContext provides the amazon attach-to-account action context.
type AttachToAccountAmazonContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewAttachToAccountAmazonContext parses the incoming request URL and body, performs validations and creates the
// context used by the amazon controller attach-to-account action.
func NewAttachToAccountAmazonContext(ctx context.Context, r *http.Request, service *goa.Service) (*AttachToAccountAmazonContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := AttachToAccountAmazonContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *AttachToAccountAmazonContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *AttachToAccountAmazonContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// DetachFromAccountAmazonContext provides the amazon detach-from-account action context.
type DetachFromAccountAmazonContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewDetachFromAccountAmazonContext parses the incoming request URL and body, performs validations and creates the
// context used by the amazon controller detach-from-account action.
func NewDetachFromAccountAmazonContext(ctx context.Context, r *http.Request, service *goa.Service) (*DetachFromAccountAmazonContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := DetachFromAccountAmazonContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *DetachFromAccountAmazonContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *DetachFromAccountAmazonContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *DetachFromAccountAmazonContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *DetachFromAccountAmazonContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// LoginAmazonContext provides the amazon login action context.
type LoginAmazonContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Token *uuid.UUID
}

// NewLoginAmazonContext parses the incoming request URL and body, performs validations and creates the
// context used by the amazon controller login action.
func NewLoginAmazonContext(ctx context.Context, r *http.Request, service *goa.Service) (*LoginAmazonContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := LoginAmazonContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramToken := req.Params["token"]
	if len(paramToken) > 0 {
		rawToken := paramToken[0]
		if token, err2 := uuid.FromString(rawToken); err2 == nil {
			tmp1 := &token
			rctx.Token = tmp1
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("token", rawToken, "uuid"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *LoginAmazonContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *LoginAmazonContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// ReceiveAmazonContext provides the amazon receive action context.
type ReceiveAmazonContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Code  string
	State uuid.UUID
}

// NewReceiveAmazonContext parses the incoming request URL and body, performs validations and creates the
// context used by the amazon controller receive action.
func NewReceiveAmazonContext(ctx context.Context, r *http.Request, service *goa.Service) (*ReceiveAmazonContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ReceiveAmazonContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramCode := req.Params["code"]
	if len(paramCode) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("code"))
	} else {
		rawCode := paramCode[0]
		rctx.Code = rawCode
	}
	paramState := req.Params["state"]
	if len(paramState) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("state"))
	} else {
		rawState := paramState[0]
		if state, err2 := uuid.FromString(rawState); err2 == nil {
			rctx.State = state
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("state", rawState, "uuid"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ReceiveAmazonContext) OK(r interface{}) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *ReceiveAmazonContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Unauthorized sends a HTTP response with status code 401.
func (ctx *ReceiveAmazonContext) Unauthorized(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 401, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *ReceiveAmazonContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RegisterAmazonContext provides the amazon register action context.
type RegisterAmazonContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *AmazonRegisterParams
}

// NewRegisterAmazonContext parses the incoming request URL and body, performs validations and creates the
// context used by the amazon controller register action.
func NewRegisterAmazonContext(ctx context.Context, r *http.Request, service *goa.Service) (*RegisterAmazonContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RegisterAmazonContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OKAdmin sends a HTTP response with status code 200.
func (ctx *RegisterAmazonContext) OKAdmin(r *UserAdmin) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OK sends a HTTP response with status code 200.
func (ctx *RegisterAmazonContext) OK(r *User) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKOwner sends a HTTP response with status code 200.
func (ctx *RegisterAmazonContext) OKOwner(r *UserOwner) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *RegisterAmazonContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *RegisterAmazonContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *RegisterAmazonContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RegisterAmazonContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RegisterURLAmazonContext provides the amazon register-url action context.
type RegisterURLAmazonContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewRegisterURLAmazonContext parses the incoming request URL and body, performs validations and creates the
// context used by the amazon controller register-url action.
func NewRegisterURLAmazonContext(ctx context.Context, r *http.Request, service *goa.Service) (*RegisterURLAmazonContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RegisterURLAmazonContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *RegisterURLAmazonContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RegisterURLAmazonContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// AddPostBookmarkContext provides the bookmark addPost action context.
type AddPostBookmarkContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *BookmarkParams
}

// NewAddPostBookmarkContext parses the incoming request URL and body, performs validations and creates the
// context used by the bookmark controller addPost action.
func NewAddPostBookmarkContext(ctx context.Context, r *http.Request, service *goa.Service) (*AddPostBookmarkContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := AddPostBookmarkContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *AddPostBookmarkContext) OK(r *Bookmark) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *AddPostBookmarkContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Unauthorized sends a HTTP response with status code 401.
func (ctx *AddPostBookmarkContext) Unauthorized(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 401, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *AddPostBookmarkContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *AddPostBookmarkContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// AddVideoBookmarkContext provides the bookmark addVideo action context.
type AddVideoBookmarkContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *BookmarkParams
}

// NewAddVideoBookmarkContext parses the incoming request URL and body, performs validations and creates the
// context used by the bookmark controller addVideo action.
func NewAddVideoBookmarkContext(ctx context.Context, r *http.Request, service *goa.Service) (*AddVideoBookmarkContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := AddVideoBookmarkContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *AddVideoBookmarkContext) OK(r *Bookmark) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *AddVideoBookmarkContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Unauthorized sends a HTTP response with status code 401.
func (ctx *AddVideoBookmarkContext) Unauthorized(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 401, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *AddVideoBookmarkContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *AddVideoBookmarkContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// GetBookmarksBookmarkContext provides the bookmark getBookmarks action context.
type GetBookmarksBookmarkContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewGetBookmarksBookmarkContext parses the incoming request URL and body, performs validations and creates the
// context used by the bookmark controller getBookmarks action.
func NewGetBookmarksBookmarkContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetBookmarksBookmarkContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetBookmarksBookmarkContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetBookmarksBookmarkContext) OK(r []*Bookmark) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "bookmark")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *GetBookmarksBookmarkContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Unauthorized sends a HTTP response with status code 401.
func (ctx *GetBookmarksBookmarkContext) Unauthorized(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 401, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *GetBookmarksBookmarkContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *GetBookmarksBookmarkContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// GetPostBookmarksBookmarkContext provides the bookmark getPostBookmarks action context.
type GetPostBookmarksBookmarkContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewGetPostBookmarksBookmarkContext parses the incoming request URL and body, performs validations and creates the
// context used by the bookmark controller getPostBookmarks action.
func NewGetPostBookmarksBookmarkContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetPostBookmarksBookmarkContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetPostBookmarksBookmarkContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetPostBookmarksBookmarkContext) OK(r []*Bookmark) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "bookmark")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *GetPostBookmarksBookmarkContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Unauthorized sends a HTTP response with status code 401.
func (ctx *GetPostBookmarksBookmarkContext) Unauthorized(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 401, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *GetPostBookmarksBookmarkContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *GetPostBookmarksBookmarkContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// GetVideoBookmarksBookmarkContext provides the bookmark getVideoBookmarks action context.
type GetVideoBookmarksBookmarkContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewGetVideoBookmarksBookmarkContext parses the incoming request URL and body, performs validations and creates the
// context used by the bookmark controller getVideoBookmarks action.
func NewGetVideoBookmarksBookmarkContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetVideoBookmarksBookmarkContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetVideoBookmarksBookmarkContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetVideoBookmarksBookmarkContext) OK(r []*Bookmark) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "bookmark")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *GetVideoBookmarksBookmarkContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Unauthorized sends a HTTP response with status code 401.
func (ctx *GetVideoBookmarksBookmarkContext) Unauthorized(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 401, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *GetVideoBookmarksBookmarkContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *GetVideoBookmarksBookmarkContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RemoveFromBookmarkBookmarkContext provides the bookmark removeFromBookmark action context.
type RemoveFromBookmarkBookmarkContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID *string
}

// NewRemoveFromBookmarkBookmarkContext parses the incoming request URL and body, performs validations and creates the
// context used by the bookmark controller removeFromBookmark action.
func NewRemoveFromBookmarkBookmarkContext(ctx context.Context, r *http.Request, service *goa.Service) (*RemoveFromBookmarkBookmarkContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RemoveFromBookmarkBookmarkContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = &rawID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *RemoveFromBookmarkBookmarkContext) OK(r *Bookmark) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *RemoveFromBookmarkBookmarkContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Unauthorized sends a HTTP response with status code 401.
func (ctx *RemoveFromBookmarkBookmarkContext) Unauthorized(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 401, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *RemoveFromBookmarkBookmarkContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RemoveFromBookmarkBookmarkContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// AttachToAccountFacebookContext provides the facebook attach-to-account action context.
type AttachToAccountFacebookContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewAttachToAccountFacebookContext parses the incoming request URL and body, performs validations and creates the
// context used by the facebook controller attach-to-account action.
func NewAttachToAccountFacebookContext(ctx context.Context, r *http.Request, service *goa.Service) (*AttachToAccountFacebookContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := AttachToAccountFacebookContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *AttachToAccountFacebookContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *AttachToAccountFacebookContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// DetachFromAccountFacebookContext provides the facebook detach-from-account action context.
type DetachFromAccountFacebookContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewDetachFromAccountFacebookContext parses the incoming request URL and body, performs validations and creates the
// context used by the facebook controller detach-from-account action.
func NewDetachFromAccountFacebookContext(ctx context.Context, r *http.Request, service *goa.Service) (*DetachFromAccountFacebookContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := DetachFromAccountFacebookContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *DetachFromAccountFacebookContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *DetachFromAccountFacebookContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *DetachFromAccountFacebookContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *DetachFromAccountFacebookContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// LoginFacebookContext provides the facebook login action context.
type LoginFacebookContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Token *uuid.UUID
}

// NewLoginFacebookContext parses the incoming request URL and body, performs validations and creates the
// context used by the facebook controller login action.
func NewLoginFacebookContext(ctx context.Context, r *http.Request, service *goa.Service) (*LoginFacebookContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := LoginFacebookContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramToken := req.Params["token"]
	if len(paramToken) > 0 {
		rawToken := paramToken[0]
		if token, err2 := uuid.FromString(rawToken); err2 == nil {
			tmp3 := &token
			rctx.Token = tmp3
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("token", rawToken, "uuid"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *LoginFacebookContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *LoginFacebookContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// ReceiveFacebookContext provides the facebook receive action context.
type ReceiveFacebookContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Code  string
	State uuid.UUID
}

// NewReceiveFacebookContext parses the incoming request URL and body, performs validations and creates the
// context used by the facebook controller receive action.
func NewReceiveFacebookContext(ctx context.Context, r *http.Request, service *goa.Service) (*ReceiveFacebookContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ReceiveFacebookContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramCode := req.Params["code"]
	if len(paramCode) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("code"))
	} else {
		rawCode := paramCode[0]
		rctx.Code = rawCode
	}
	paramState := req.Params["state"]
	if len(paramState) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("state"))
	} else {
		rawState := paramState[0]
		if state, err2 := uuid.FromString(rawState); err2 == nil {
			rctx.State = state
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("state", rawState, "uuid"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ReceiveFacebookContext) OK(r interface{}) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *ReceiveFacebookContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Unauthorized sends a HTTP response with status code 401.
func (ctx *ReceiveFacebookContext) Unauthorized(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 401, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *ReceiveFacebookContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RegisterFacebookContext provides the facebook register action context.
type RegisterFacebookContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *FacebookRegisterParams
}

// NewRegisterFacebookContext parses the incoming request URL and body, performs validations and creates the
// context used by the facebook controller register action.
func NewRegisterFacebookContext(ctx context.Context, r *http.Request, service *goa.Service) (*RegisterFacebookContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RegisterFacebookContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OKAdmin sends a HTTP response with status code 200.
func (ctx *RegisterFacebookContext) OKAdmin(r *UserAdmin) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OK sends a HTTP response with status code 200.
func (ctx *RegisterFacebookContext) OK(r *User) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKOwner sends a HTTP response with status code 200.
func (ctx *RegisterFacebookContext) OKOwner(r *UserOwner) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *RegisterFacebookContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *RegisterFacebookContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *RegisterFacebookContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RegisterFacebookContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RegisterURLFacebookContext provides the facebook register-url action context.
type RegisterURLFacebookContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewRegisterURLFacebookContext parses the incoming request URL and body, performs validations and creates the
// context used by the facebook controller register-url action.
func NewRegisterURLFacebookContext(ctx context.Context, r *http.Request, service *goa.Service) (*RegisterURLFacebookContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RegisterURLFacebookContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *RegisterURLFacebookContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RegisterURLFacebookContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// AttachToAccountGoogleContext provides the google attach-to-account action context.
type AttachToAccountGoogleContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewAttachToAccountGoogleContext parses the incoming request URL and body, performs validations and creates the
// context used by the google controller attach-to-account action.
func NewAttachToAccountGoogleContext(ctx context.Context, r *http.Request, service *goa.Service) (*AttachToAccountGoogleContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := AttachToAccountGoogleContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *AttachToAccountGoogleContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *AttachToAccountGoogleContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// DetachFromAccountGoogleContext provides the google detach-from-account action context.
type DetachFromAccountGoogleContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewDetachFromAccountGoogleContext parses the incoming request URL and body, performs validations and creates the
// context used by the google controller detach-from-account action.
func NewDetachFromAccountGoogleContext(ctx context.Context, r *http.Request, service *goa.Service) (*DetachFromAccountGoogleContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := DetachFromAccountGoogleContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *DetachFromAccountGoogleContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *DetachFromAccountGoogleContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *DetachFromAccountGoogleContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *DetachFromAccountGoogleContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// LoginGoogleContext provides the google login action context.
type LoginGoogleContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Token *uuid.UUID
}

// NewLoginGoogleContext parses the incoming request URL and body, performs validations and creates the
// context used by the google controller login action.
func NewLoginGoogleContext(ctx context.Context, r *http.Request, service *goa.Service) (*LoginGoogleContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := LoginGoogleContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramToken := req.Params["token"]
	if len(paramToken) > 0 {
		rawToken := paramToken[0]
		if token, err2 := uuid.FromString(rawToken); err2 == nil {
			tmp5 := &token
			rctx.Token = tmp5
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("token", rawToken, "uuid"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *LoginGoogleContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *LoginGoogleContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// ReceiveGoogleContext provides the google receive action context.
type ReceiveGoogleContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Code  string
	State uuid.UUID
}

// NewReceiveGoogleContext parses the incoming request URL and body, performs validations and creates the
// context used by the google controller receive action.
func NewReceiveGoogleContext(ctx context.Context, r *http.Request, service *goa.Service) (*ReceiveGoogleContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ReceiveGoogleContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramCode := req.Params["code"]
	if len(paramCode) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("code"))
	} else {
		rawCode := paramCode[0]
		rctx.Code = rawCode
	}
	paramState := req.Params["state"]
	if len(paramState) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("state"))
	} else {
		rawState := paramState[0]
		if state, err2 := uuid.FromString(rawState); err2 == nil {
			rctx.State = state
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("state", rawState, "uuid"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ReceiveGoogleContext) OK(r interface{}) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *ReceiveGoogleContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Unauthorized sends a HTTP response with status code 401.
func (ctx *ReceiveGoogleContext) Unauthorized(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 401, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *ReceiveGoogleContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RegisterGoogleContext provides the google register action context.
type RegisterGoogleContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *GoogleRegisterParams
}

// NewRegisterGoogleContext parses the incoming request URL and body, performs validations and creates the
// context used by the google controller register action.
func NewRegisterGoogleContext(ctx context.Context, r *http.Request, service *goa.Service) (*RegisterGoogleContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RegisterGoogleContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OKAdmin sends a HTTP response with status code 200.
func (ctx *RegisterGoogleContext) OKAdmin(r *UserAdmin) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OK sends a HTTP response with status code 200.
func (ctx *RegisterGoogleContext) OK(r *User) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKOwner sends a HTTP response with status code 200.
func (ctx *RegisterGoogleContext) OKOwner(r *UserOwner) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *RegisterGoogleContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *RegisterGoogleContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *RegisterGoogleContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RegisterGoogleContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RegisterURLGoogleContext provides the google register-url action context.
type RegisterURLGoogleContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewRegisterURLGoogleContext parses the incoming request URL and body, performs validations and creates the
// context used by the google controller register-url action.
func NewRegisterURLGoogleContext(ctx context.Context, r *http.Request, service *goa.Service) (*RegisterURLGoogleContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RegisterURLGoogleContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *RegisterURLGoogleContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RegisterURLGoogleContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// AttachToAccountLinkedinContext provides the linkedin attach-to-account action context.
type AttachToAccountLinkedinContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewAttachToAccountLinkedinContext parses the incoming request URL and body, performs validations and creates the
// context used by the linkedin controller attach-to-account action.
func NewAttachToAccountLinkedinContext(ctx context.Context, r *http.Request, service *goa.Service) (*AttachToAccountLinkedinContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := AttachToAccountLinkedinContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *AttachToAccountLinkedinContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *AttachToAccountLinkedinContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// DetachFromAccountLinkedinContext provides the linkedin detach-from-account action context.
type DetachFromAccountLinkedinContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewDetachFromAccountLinkedinContext parses the incoming request URL and body, performs validations and creates the
// context used by the linkedin controller detach-from-account action.
func NewDetachFromAccountLinkedinContext(ctx context.Context, r *http.Request, service *goa.Service) (*DetachFromAccountLinkedinContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := DetachFromAccountLinkedinContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *DetachFromAccountLinkedinContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *DetachFromAccountLinkedinContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *DetachFromAccountLinkedinContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *DetachFromAccountLinkedinContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// LoginLinkedinContext provides the linkedin login action context.
type LoginLinkedinContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Token *uuid.UUID
}

// NewLoginLinkedinContext parses the incoming request URL and body, performs validations and creates the
// context used by the linkedin controller login action.
func NewLoginLinkedinContext(ctx context.Context, r *http.Request, service *goa.Service) (*LoginLinkedinContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := LoginLinkedinContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramToken := req.Params["token"]
	if len(paramToken) > 0 {
		rawToken := paramToken[0]
		if token, err2 := uuid.FromString(rawToken); err2 == nil {
			tmp7 := &token
			rctx.Token = tmp7
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("token", rawToken, "uuid"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *LoginLinkedinContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *LoginLinkedinContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// ReceiveLinkedinContext provides the linkedin receive action context.
type ReceiveLinkedinContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Code  string
	State uuid.UUID
}

// NewReceiveLinkedinContext parses the incoming request URL and body, performs validations and creates the
// context used by the linkedin controller receive action.
func NewReceiveLinkedinContext(ctx context.Context, r *http.Request, service *goa.Service) (*ReceiveLinkedinContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ReceiveLinkedinContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramCode := req.Params["code"]
	if len(paramCode) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("code"))
	} else {
		rawCode := paramCode[0]
		rctx.Code = rawCode
	}
	paramState := req.Params["state"]
	if len(paramState) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("state"))
	} else {
		rawState := paramState[0]
		if state, err2 := uuid.FromString(rawState); err2 == nil {
			rctx.State = state
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("state", rawState, "uuid"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ReceiveLinkedinContext) OK(r interface{}) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *ReceiveLinkedinContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Unauthorized sends a HTTP response with status code 401.
func (ctx *ReceiveLinkedinContext) Unauthorized(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 401, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *ReceiveLinkedinContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RegisterLinkedinContext provides the linkedin register action context.
type RegisterLinkedinContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *LinkedinRegisterParams
}

// NewRegisterLinkedinContext parses the incoming request URL and body, performs validations and creates the
// context used by the linkedin controller register action.
func NewRegisterLinkedinContext(ctx context.Context, r *http.Request, service *goa.Service) (*RegisterLinkedinContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RegisterLinkedinContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OKAdmin sends a HTTP response with status code 200.
func (ctx *RegisterLinkedinContext) OKAdmin(r *UserAdmin) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OK sends a HTTP response with status code 200.
func (ctx *RegisterLinkedinContext) OK(r *User) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKOwner sends a HTTP response with status code 200.
func (ctx *RegisterLinkedinContext) OKOwner(r *UserOwner) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *RegisterLinkedinContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *RegisterLinkedinContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *RegisterLinkedinContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RegisterLinkedinContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RegisterURLLinkedinContext provides the linkedin register-url action context.
type RegisterURLLinkedinContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewRegisterURLLinkedinContext parses the incoming request URL and body, performs validations and creates the
// context used by the linkedin controller register-url action.
func NewRegisterURLLinkedinContext(ctx context.Context, r *http.Request, service *goa.Service) (*RegisterURLLinkedinContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RegisterURLLinkedinContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *RegisterURLLinkedinContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RegisterURLLinkedinContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// AttachToAccountMicrosoftContext provides the microsoft attach-to-account action context.
type AttachToAccountMicrosoftContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewAttachToAccountMicrosoftContext parses the incoming request URL and body, performs validations and creates the
// context used by the microsoft controller attach-to-account action.
func NewAttachToAccountMicrosoftContext(ctx context.Context, r *http.Request, service *goa.Service) (*AttachToAccountMicrosoftContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := AttachToAccountMicrosoftContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *AttachToAccountMicrosoftContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *AttachToAccountMicrosoftContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// DetachFromAccountMicrosoftContext provides the microsoft detach-from-account action context.
type DetachFromAccountMicrosoftContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewDetachFromAccountMicrosoftContext parses the incoming request URL and body, performs validations and creates the
// context used by the microsoft controller detach-from-account action.
func NewDetachFromAccountMicrosoftContext(ctx context.Context, r *http.Request, service *goa.Service) (*DetachFromAccountMicrosoftContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := DetachFromAccountMicrosoftContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *DetachFromAccountMicrosoftContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *DetachFromAccountMicrosoftContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *DetachFromAccountMicrosoftContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *DetachFromAccountMicrosoftContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// LoginMicrosoftContext provides the microsoft login action context.
type LoginMicrosoftContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Token *uuid.UUID
}

// NewLoginMicrosoftContext parses the incoming request URL and body, performs validations and creates the
// context used by the microsoft controller login action.
func NewLoginMicrosoftContext(ctx context.Context, r *http.Request, service *goa.Service) (*LoginMicrosoftContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := LoginMicrosoftContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramToken := req.Params["token"]
	if len(paramToken) > 0 {
		rawToken := paramToken[0]
		if token, err2 := uuid.FromString(rawToken); err2 == nil {
			tmp9 := &token
			rctx.Token = tmp9
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("token", rawToken, "uuid"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *LoginMicrosoftContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *LoginMicrosoftContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// ReceiveMicrosoftContext provides the microsoft receive action context.
type ReceiveMicrosoftContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Code  string
	State uuid.UUID
}

// NewReceiveMicrosoftContext parses the incoming request URL and body, performs validations and creates the
// context used by the microsoft controller receive action.
func NewReceiveMicrosoftContext(ctx context.Context, r *http.Request, service *goa.Service) (*ReceiveMicrosoftContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ReceiveMicrosoftContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramCode := req.Params["code"]
	if len(paramCode) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("code"))
	} else {
		rawCode := paramCode[0]
		rctx.Code = rawCode
	}
	paramState := req.Params["state"]
	if len(paramState) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("state"))
	} else {
		rawState := paramState[0]
		if state, err2 := uuid.FromString(rawState); err2 == nil {
			rctx.State = state
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("state", rawState, "uuid"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ReceiveMicrosoftContext) OK(r interface{}) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *ReceiveMicrosoftContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Unauthorized sends a HTTP response with status code 401.
func (ctx *ReceiveMicrosoftContext) Unauthorized(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 401, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *ReceiveMicrosoftContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RegisterMicrosoftContext provides the microsoft register action context.
type RegisterMicrosoftContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *MicrosoftRegisterParams
}

// NewRegisterMicrosoftContext parses the incoming request URL and body, performs validations and creates the
// context used by the microsoft controller register action.
func NewRegisterMicrosoftContext(ctx context.Context, r *http.Request, service *goa.Service) (*RegisterMicrosoftContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RegisterMicrosoftContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OKAdmin sends a HTTP response with status code 200.
func (ctx *RegisterMicrosoftContext) OKAdmin(r *UserAdmin) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OK sends a HTTP response with status code 200.
func (ctx *RegisterMicrosoftContext) OK(r *User) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKOwner sends a HTTP response with status code 200.
func (ctx *RegisterMicrosoftContext) OKOwner(r *UserOwner) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *RegisterMicrosoftContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *RegisterMicrosoftContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *RegisterMicrosoftContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RegisterMicrosoftContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RegisterURLMicrosoftContext provides the microsoft register-url action context.
type RegisterURLMicrosoftContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewRegisterURLMicrosoftContext parses the incoming request URL and body, performs validations and creates the
// context used by the microsoft controller register-url action.
func NewRegisterURLMicrosoftContext(ctx context.Context, r *http.Request, service *goa.Service) (*RegisterURLMicrosoftContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RegisterURLMicrosoftContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *RegisterURLMicrosoftContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RegisterURLMicrosoftContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// AddSubscriberNewsletterContext provides the newsletter add-subscriber action context.
type AddSubscriberNewsletterContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *NewsletterParam
}

// NewAddSubscriberNewsletterContext parses the incoming request URL and body, performs validations and creates the
// context used by the newsletter controller add-subscriber action.
func NewAddSubscriberNewsletterContext(ctx context.Context, r *http.Request, service *goa.Service) (*AddSubscriberNewsletterContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := AddSubscriberNewsletterContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *AddSubscriberNewsletterContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *AddSubscriberNewsletterContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *AddSubscriberNewsletterContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *AddSubscriberNewsletterContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// GetSubscriberByEmailNewsletterContext provides the newsletter get-subscriber-by-email action context.
type GetSubscriberByEmailNewsletterContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Email *string
}

// NewGetSubscriberByEmailNewsletterContext parses the incoming request URL and body, performs validations and creates the
// context used by the newsletter controller get-subscriber-by-email action.
func NewGetSubscriberByEmailNewsletterContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetSubscriberByEmailNewsletterContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetSubscriberByEmailNewsletterContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramEmail := req.Params["email"]
	if len(paramEmail) > 0 {
		rawEmail := paramEmail[0]
		rctx.Email = &rawEmail
		if rctx.Email != nil {
			if err2 := goa.ValidateFormat(goa.FormatEmail, *rctx.Email); err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFormatError(`email`, *rctx.Email, goa.FormatEmail, err2))
			}
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetSubscriberByEmailNewsletterContext) OK(r *NewsletterSubscriber) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *GetSubscriberByEmailNewsletterContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *GetSubscriberByEmailNewsletterContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *GetSubscriberByEmailNewsletterContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// GetSubscribersNewsletterContext provides the newsletter get-subscribers action context.
type GetSubscribersNewsletterContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewGetSubscribersNewsletterContext parses the incoming request URL and body, performs validations and creates the
// context used by the newsletter controller get-subscribers action.
func NewGetSubscribersNewsletterContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetSubscribersNewsletterContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetSubscribersNewsletterContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetSubscribersNewsletterContext) OK(r NewsletterSubscriberCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "newsletter-subscriber; type=collection")
	}
	if r == nil {
		r = NewsletterSubscriberCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *GetSubscribersNewsletterContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *GetSubscribersNewsletterContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *GetSubscribersNewsletterContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RemoveSubscriberNewsletterContext provides the newsletter remove-subscriber action context.
type RemoveSubscriberNewsletterContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Email *string
}

// NewRemoveSubscriberNewsletterContext parses the incoming request URL and body, performs validations and creates the
// context used by the newsletter controller remove-subscriber action.
func NewRemoveSubscriberNewsletterContext(ctx context.Context, r *http.Request, service *goa.Service) (*RemoveSubscriberNewsletterContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RemoveSubscriberNewsletterContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramEmail := req.Params["email"]
	if len(paramEmail) > 0 {
		rawEmail := paramEmail[0]
		rctx.Email = &rawEmail
		if rctx.Email != nil {
			if err2 := goa.ValidateFormat(goa.FormatEmail, *rctx.Email); err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFormatError(`email`, *rctx.Email, goa.FormatEmail, err2))
			}
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *RemoveSubscriberNewsletterContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *RemoveSubscriberNewsletterContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *RemoveSubscriberNewsletterContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RemoveSubscriberNewsletterContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// UpdateSubscriberNewsletterContext provides the newsletter update-subscriber action context.
type UpdateSubscriberNewsletterContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *NewsletterParam
}

// NewUpdateSubscriberNewsletterContext parses the incoming request URL and body, performs validations and creates the
// context used by the newsletter controller update-subscriber action.
func NewUpdateSubscriberNewsletterContext(ctx context.Context, r *http.Request, service *goa.Service) (*UpdateSubscriberNewsletterContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := UpdateSubscriberNewsletterContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *UpdateSubscriberNewsletterContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *UpdateSubscriberNewsletterContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *UpdateSubscriberNewsletterContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *UpdateSubscriberNewsletterContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// ChangePasswordPasswordAuthContext provides the password-auth change-password action context.
type ChangePasswordPasswordAuthContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *ChangePasswordParams
}

// NewChangePasswordPasswordAuthContext parses the incoming request URL and body, performs validations and creates the
// context used by the password-auth controller change-password action.
func NewChangePasswordPasswordAuthContext(ctx context.Context, r *http.Request, service *goa.Service) (*ChangePasswordPasswordAuthContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ChangePasswordPasswordAuthContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ChangePasswordPasswordAuthContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *ChangePasswordPasswordAuthContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *ChangePasswordPasswordAuthContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// ConfirmResetPasswordAuthContext provides the password-auth confirm-reset action context.
type ConfirmResetPasswordAuthContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *ResetPasswordParams
}

// NewConfirmResetPasswordAuthContext parses the incoming request URL and body, performs validations and creates the
// context used by the password-auth controller confirm-reset action.
func NewConfirmResetPasswordAuthContext(ctx context.Context, r *http.Request, service *goa.Service) (*ConfirmResetPasswordAuthContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ConfirmResetPasswordAuthContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ConfirmResetPasswordAuthContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *ConfirmResetPasswordAuthContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *ConfirmResetPasswordAuthContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// LoginPasswordAuthContext provides the password-auth login action context.
type LoginPasswordAuthContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Token   *uuid.UUID
	Payload *LoginParams
}

// NewLoginPasswordAuthContext parses the incoming request URL and body, performs validations and creates the
// context used by the password-auth controller login action.
func NewLoginPasswordAuthContext(ctx context.Context, r *http.Request, service *goa.Service) (*LoginPasswordAuthContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := LoginPasswordAuthContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramToken := req.Params["token"]
	if len(paramToken) > 0 {
		rawToken := paramToken[0]
		if token, err2 := uuid.FromString(rawToken); err2 == nil {
			tmp11 := &token
			rctx.Token = tmp11
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("token", rawToken, "uuid"))
		}
	}
	return &rctx, err
}

// OKAdmin sends a HTTP response with status code 200.
func (ctx *LoginPasswordAuthContext) OKAdmin(r *UserAdmin) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OK sends a HTTP response with status code 200.
func (ctx *LoginPasswordAuthContext) OK(r *User) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKOwner sends a HTTP response with status code 200.
func (ctx *LoginPasswordAuthContext) OKOwner(r *UserOwner) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *LoginPasswordAuthContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Unauthorized sends a HTTP response with status code 401.
func (ctx *LoginPasswordAuthContext) Unauthorized(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 401, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *LoginPasswordAuthContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RegisterPasswordAuthContext provides the password-auth register action context.
type RegisterPasswordAuthContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *RegisterParams
}

// NewRegisterPasswordAuthContext parses the incoming request URL and body, performs validations and creates the
// context used by the password-auth controller register action.
func NewRegisterPasswordAuthContext(ctx context.Context, r *http.Request, service *goa.Service) (*RegisterPasswordAuthContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RegisterPasswordAuthContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OKAdmin sends a HTTP response with status code 200.
func (ctx *RegisterPasswordAuthContext) OKAdmin(r *UserAdmin) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OK sends a HTTP response with status code 200.
func (ctx *RegisterPasswordAuthContext) OK(r *User) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKOwner sends a HTTP response with status code 200.
func (ctx *RegisterPasswordAuthContext) OKOwner(r *UserOwner) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *RegisterPasswordAuthContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *RegisterPasswordAuthContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RegisterPasswordAuthContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RemovePasswordAuthContext provides the password-auth remove action context.
type RemovePasswordAuthContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewRemovePasswordAuthContext parses the incoming request URL and body, performs validations and creates the
// context used by the password-auth controller remove action.
func NewRemovePasswordAuthContext(ctx context.Context, r *http.Request, service *goa.Service) (*RemovePasswordAuthContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RemovePasswordAuthContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *RemovePasswordAuthContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *RemovePasswordAuthContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *RemovePasswordAuthContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RemovePasswordAuthContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// ResetPasswordAuthContext provides the password-auth reset action context.
type ResetPasswordAuthContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Email       string
	RedirectURL string
}

// NewResetPasswordAuthContext parses the incoming request URL and body, performs validations and creates the
// context used by the password-auth controller reset action.
func NewResetPasswordAuthContext(ctx context.Context, r *http.Request, service *goa.Service) (*ResetPasswordAuthContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ResetPasswordAuthContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramEmail := req.Params["email"]
	if len(paramEmail) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("email"))
	} else {
		rawEmail := paramEmail[0]
		rctx.Email = rawEmail
		if err2 := goa.ValidateFormat(goa.FormatEmail, rctx.Email); err2 != nil {
			err = goa.MergeErrors(err, goa.InvalidFormatError(`email`, rctx.Email, goa.FormatEmail, err2))
		}
	}
	paramRedirectURL := req.Params["redirect-url"]
	if len(paramRedirectURL) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("redirect-url"))
	} else {
		rawRedirectURL := paramRedirectURL[0]
		rctx.RedirectURL = rawRedirectURL
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ResetPasswordAuthContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *ResetPasswordAuthContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// CleanLoginTokenSessionContext provides the session clean-login-token action context.
type CleanLoginTokenSessionContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewCleanLoginTokenSessionContext parses the incoming request URL and body, performs validations and creates the
// context used by the session controller clean-login-token action.
func NewCleanLoginTokenSessionContext(ctx context.Context, r *http.Request, service *goa.Service) (*CleanLoginTokenSessionContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := CleanLoginTokenSessionContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *CleanLoginTokenSessionContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *CleanLoginTokenSessionContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// CleanMergeTokenSessionContext provides the session clean-merge-token action context.
type CleanMergeTokenSessionContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewCleanMergeTokenSessionContext parses the incoming request URL and body, performs validations and creates the
// context used by the session controller clean-merge-token action.
func NewCleanMergeTokenSessionContext(ctx context.Context, r *http.Request, service *goa.Service) (*CleanMergeTokenSessionContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := CleanMergeTokenSessionContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *CleanMergeTokenSessionContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *CleanMergeTokenSessionContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// CleanSessionsSessionContext provides the session clean-sessions action context.
type CleanSessionsSessionContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewCleanSessionsSessionContext parses the incoming request URL and body, performs validations and creates the
// context used by the session controller clean-sessions action.
func NewCleanSessionsSessionContext(ctx context.Context, r *http.Request, service *goa.Service) (*CleanSessionsSessionContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := CleanSessionsSessionContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *CleanSessionsSessionContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *CleanSessionsSessionContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// GetSessionsSessionContext provides the session get-sessions action context.
type GetSessionsSessionContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewGetSessionsSessionContext parses the incoming request URL and body, performs validations and creates the
// context used by the session controller get-sessions action.
func NewGetSessionsSessionContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetSessionsSessionContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetSessionsSessionContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetSessionsSessionContext) OK(r *AllSessions) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "all-sessions")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *GetSessionsSessionContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// LogoutSessionContext provides the session logout action context.
type LogoutSessionContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewLogoutSessionContext parses the incoming request URL and body, performs validations and creates the
// context used by the session controller logout action.
func NewLogoutSessionContext(ctx context.Context, r *http.Request, service *goa.Service) (*LogoutSessionContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := LogoutSessionContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *LogoutSessionContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *LogoutSessionContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *LogoutSessionContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// LogoutOtherSessionContext provides the session logout-other action context.
type LogoutOtherSessionContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewLogoutOtherSessionContext parses the incoming request URL and body, performs validations and creates the
// context used by the session controller logout-other action.
func NewLogoutOtherSessionContext(ctx context.Context, r *http.Request, service *goa.Service) (*LogoutOtherSessionContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := LogoutOtherSessionContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *LogoutOtherSessionContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *LogoutOtherSessionContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *LogoutOtherSessionContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// LogoutSpecificSessionContext provides the session logout-specific action context.
type LogoutSpecificSessionContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Session   string
	SessionID string
}

// NewLogoutSpecificSessionContext parses the incoming request URL and body, performs validations and creates the
// context used by the session controller logout-specific action.
func NewLogoutSpecificSessionContext(ctx context.Context, r *http.Request, service *goa.Service) (*LogoutSpecificSessionContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := LogoutSpecificSessionContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramSession := req.Params["session"]
	if len(paramSession) > 0 {
		rawSession := paramSession[0]
		rctx.Session = rawSession
	}
	paramSessionID := req.Params["session-id"]
	if len(paramSessionID) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("session-id"))
	} else {
		rawSessionID := paramSessionID[0]
		rctx.SessionID = rawSessionID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *LogoutSpecificSessionContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *LogoutSpecificSessionContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *LogoutSpecificSessionContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *LogoutSpecificSessionContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RedeemTokenSessionContext provides the session redeemToken action context.
type RedeemTokenSessionContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *RedeemTokenSessionPayload
}

// NewRedeemTokenSessionContext parses the incoming request URL and body, performs validations and creates the
// context used by the session controller redeemToken action.
func NewRedeemTokenSessionContext(ctx context.Context, r *http.Request, service *goa.Service) (*RedeemTokenSessionContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RedeemTokenSessionContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// redeemTokenSessionPayload is the session redeemToken action payload.
type redeemTokenSessionPayload struct {
	// The token to redeem
	Token *uuid.UUID `form:"token,omitempty" json:"token,omitempty" yaml:"token,omitempty" xml:"token,omitempty"`
}

// Validate runs the validation rules defined in the design.
func (payload *redeemTokenSessionPayload) Validate() (err error) {
	if payload.Token == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "token"))
	}
	return
}

// Publicize creates RedeemTokenSessionPayload from redeemTokenSessionPayload
func (payload *redeemTokenSessionPayload) Publicize() *RedeemTokenSessionPayload {
	var pub RedeemTokenSessionPayload
	if payload.Token != nil {
		pub.Token = *payload.Token
	}
	return &pub
}

// RedeemTokenSessionPayload is the session redeemToken action payload.
type RedeemTokenSessionPayload struct {
	// The token to redeem
	Token uuid.UUID `form:"token" json:"token" yaml:"token" xml:"token"`
}

// Created sends a HTTP response with status code 201.
func (ctx *RedeemTokenSessionContext) Created() error {
	ctx.ResponseData.WriteHeader(201)
	return nil
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *RedeemTokenSessionContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RedeemTokenSessionContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RefreshSessionContext provides the session refresh action context.
type RefreshSessionContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	XSession string
}

// NewRefreshSessionContext parses the incoming request URL and body, performs validations and creates the
// context used by the session controller refresh action.
func NewRefreshSessionContext(ctx context.Context, r *http.Request, service *goa.Service) (*RefreshSessionContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RefreshSessionContext{Context: ctx, ResponseData: resp, RequestData: req}
	headerXSession := req.Header["X-Session"]
	if len(headerXSession) == 0 {
		err = goa.MergeErrors(err, goa.MissingHeaderError("X-Session"))
	} else {
		rawXSession := headerXSession[0]
		req.Params["X-Session"] = []string{rawXSession}
		rctx.XSession = rawXSession
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *RefreshSessionContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *RefreshSessionContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Unauthorized sends a HTTP response with status code 401.
func (ctx *RefreshSessionContext) Unauthorized(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 401, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RefreshSessionContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// AttachToAccountTwitterContext provides the twitter attach-to-account action context.
type AttachToAccountTwitterContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewAttachToAccountTwitterContext parses the incoming request URL and body, performs validations and creates the
// context used by the twitter controller attach-to-account action.
func NewAttachToAccountTwitterContext(ctx context.Context, r *http.Request, service *goa.Service) (*AttachToAccountTwitterContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := AttachToAccountTwitterContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *AttachToAccountTwitterContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *AttachToAccountTwitterContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// DetachFromAccountTwitterContext provides the twitter detach-from-account action context.
type DetachFromAccountTwitterContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewDetachFromAccountTwitterContext parses the incoming request URL and body, performs validations and creates the
// context used by the twitter controller detach-from-account action.
func NewDetachFromAccountTwitterContext(ctx context.Context, r *http.Request, service *goa.Service) (*DetachFromAccountTwitterContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := DetachFromAccountTwitterContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *DetachFromAccountTwitterContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *DetachFromAccountTwitterContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *DetachFromAccountTwitterContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *DetachFromAccountTwitterContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// LoginTwitterContext provides the twitter login action context.
type LoginTwitterContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Token *uuid.UUID
}

// NewLoginTwitterContext parses the incoming request URL and body, performs validations and creates the
// context used by the twitter controller login action.
func NewLoginTwitterContext(ctx context.Context, r *http.Request, service *goa.Service) (*LoginTwitterContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := LoginTwitterContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramToken := req.Params["token"]
	if len(paramToken) > 0 {
		rawToken := paramToken[0]
		if token, err2 := uuid.FromString(rawToken); err2 == nil {
			tmp12 := &token
			rctx.Token = tmp12
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("token", rawToken, "uuid"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *LoginTwitterContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *LoginTwitterContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// ReceiveTwitterContext provides the twitter receive action context.
type ReceiveTwitterContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	OauthToken    string
	OauthVerifier string
	State         string
}

// NewReceiveTwitterContext parses the incoming request URL and body, performs validations and creates the
// context used by the twitter controller receive action.
func NewReceiveTwitterContext(ctx context.Context, r *http.Request, service *goa.Service) (*ReceiveTwitterContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ReceiveTwitterContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramOauthToken := req.Params["oauth_token"]
	if len(paramOauthToken) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("oauth_token"))
	} else {
		rawOauthToken := paramOauthToken[0]
		rctx.OauthToken = rawOauthToken
	}
	paramOauthVerifier := req.Params["oauth_verifier"]
	if len(paramOauthVerifier) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("oauth_verifier"))
	} else {
		rawOauthVerifier := paramOauthVerifier[0]
		rctx.OauthVerifier = rawOauthVerifier
	}
	paramState := req.Params["state"]
	if len(paramState) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("state"))
	} else {
		rawState := paramState[0]
		rctx.State = rawState
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ReceiveTwitterContext) OK(r interface{}) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *ReceiveTwitterContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Unauthorized sends a HTTP response with status code 401.
func (ctx *ReceiveTwitterContext) Unauthorized(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 401, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *ReceiveTwitterContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RegisterTwitterContext provides the twitter register action context.
type RegisterTwitterContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *TwitterRegisterParams
}

// NewRegisterTwitterContext parses the incoming request URL and body, performs validations and creates the
// context used by the twitter controller register action.
func NewRegisterTwitterContext(ctx context.Context, r *http.Request, service *goa.Service) (*RegisterTwitterContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RegisterTwitterContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OKAdmin sends a HTTP response with status code 200.
func (ctx *RegisterTwitterContext) OKAdmin(r *UserAdmin) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OK sends a HTTP response with status code 200.
func (ctx *RegisterTwitterContext) OK(r *User) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKOwner sends a HTTP response with status code 200.
func (ctx *RegisterTwitterContext) OKOwner(r *UserOwner) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *RegisterTwitterContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *RegisterTwitterContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *RegisterTwitterContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RegisterTwitterContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RegisterURLTwitterContext provides the twitter register-url action context.
type RegisterURLTwitterContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewRegisterURLTwitterContext parses the incoming request URL and body, performs validations and creates the
// context used by the twitter controller register-url action.
func NewRegisterURLTwitterContext(ctx context.Context, r *http.Request, service *goa.Service) (*RegisterURLTwitterContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RegisterURLTwitterContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *RegisterURLTwitterContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RegisterURLTwitterContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// AddPluginUserContext provides the user add-plugin action context.
type AddPluginUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *UserPlugin
}

// NewAddPluginUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller add-plugin action.
func NewAddPluginUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*AddPluginUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := AddPluginUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OKAdmin sends a HTTP response with status code 200.
func (ctx *AddPluginUserContext) OKAdmin(r *UserAdmin) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OK sends a HTTP response with status code 200.
func (ctx *AddPluginUserContext) OK(r *User) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKOwner sends a HTTP response with status code 200.
func (ctx *AddPluginUserContext) OKOwner(r *UserOwner) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *AddPluginUserContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *AddPluginUserContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// DeactivateUserContext provides the user deactivate action context.
type DeactivateUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Admin *bool
	ID    *string
}

// NewDeactivateUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller deactivate action.
func NewDeactivateUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*DeactivateUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := DeactivateUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramAdmin := req.Params["admin"]
	if len(paramAdmin) > 0 {
		rawAdmin := paramAdmin[0]
		if admin, err2 := strconv.ParseBool(rawAdmin); err2 == nil {
			tmp13 := &admin
			rctx.Admin = tmp13
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("admin", rawAdmin, "boolean"))
		}
	}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = &rawID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *DeactivateUserContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *DeactivateUserContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *DeactivateUserContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// GetAllUsersUserContext provides the user get-all-users action context.
type GetAllUsersUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewGetAllUsersUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller get-all-users action.
func NewGetAllUsersUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetAllUsersUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetAllUsersUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetAllUsersUserContext) OK(r interface{}) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "user")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *GetAllUsersUserContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *GetAllUsersUserContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *GetAllUsersUserContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *GetAllUsersUserContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// GetByEmailUserContext provides the user get-by-email action context.
type GetByEmailUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Email string
}

// NewGetByEmailUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller get-by-email action.
func NewGetByEmailUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetByEmailUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetByEmailUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramEmail := req.Params["email"]
	if len(paramEmail) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("email"))
	} else {
		rawEmail := paramEmail[0]
		rctx.Email = rawEmail
		if err2 := goa.ValidateFormat(goa.FormatEmail, rctx.Email); err2 != nil {
			err = goa.MergeErrors(err, goa.InvalidFormatError(`email`, rctx.Email, goa.FormatEmail, err2))
		}
	}
	return &rctx, err
}

// OKAdmin sends a HTTP response with status code 200.
func (ctx *GetByEmailUserContext) OKAdmin(r *UserAdmin) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OK sends a HTTP response with status code 200.
func (ctx *GetByEmailUserContext) OK(r *User) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKOwner sends a HTTP response with status code 200.
func (ctx *GetByEmailUserContext) OKOwner(r *UserOwner) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *GetByEmailUserContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *GetByEmailUserContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// GetManyUserContext provides the user get-many action context.
type GetManyUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID []string
}

// NewGetManyUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller get-many action.
func NewGetManyUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetManyUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetManyUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		params := paramID
		rctx.ID = params
	}
	return &rctx, err
}

// OKAdmin sends a HTTP response with status code 200.
func (ctx *GetManyUserContext) OKAdmin(r UserAdminCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	if r == nil {
		r = UserAdminCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OK sends a HTTP response with status code 200.
func (ctx *GetManyUserContext) OK(r UserCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	if r == nil {
		r = UserCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKOwner sends a HTTP response with status code 200.
func (ctx *GetManyUserContext) OKOwner(r UserOwnerCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	if r == nil {
		r = UserOwnerCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *GetManyUserContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *GetManyUserContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *GetManyUserContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// GetAuthsUserContext provides the user getAuths action context.
type GetAuthsUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	UserID *string
}

// NewGetAuthsUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller getAuths action.
func NewGetAuthsUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetAuthsUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetAuthsUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramUserID := req.Params["userID"]
	if len(paramUserID) > 0 {
		rawUserID := paramUserID[0]
		rctx.UserID = &rawUserID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetAuthsUserContext) OK(r *AuthStatus) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *GetAuthsUserContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Unauthorized sends a HTTP response with status code 401.
func (ctx *GetAuthsUserContext) Unauthorized(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 401, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *GetAuthsUserContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// ResendVerifyEmailUserContext provides the user resend-verify-email action context.
type ResendVerifyEmailUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewResendVerifyEmailUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller resend-verify-email action.
func NewResendVerifyEmailUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*ResendVerifyEmailUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ResendVerifyEmailUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ResendVerifyEmailUserContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ResendVerifyEmailUserContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *ResendVerifyEmailUserContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RetrieveUserContext provides the user retrieve action context.
type RetrieveUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	UserID *string
}

// NewRetrieveUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller retrieve action.
func NewRetrieveUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*RetrieveUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RetrieveUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramUserID := req.Params["user-id"]
	if len(paramUserID) > 0 {
		rawUserID := paramUserID[0]
		rctx.UserID = &rawUserID
	}
	return &rctx, err
}

// OKAdmin sends a HTTP response with status code 200.
func (ctx *RetrieveUserContext) OKAdmin(r *UserAdmin) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OK sends a HTTP response with status code 200.
func (ctx *RetrieveUserContext) OK(r *User) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKOwner sends a HTTP response with status code 200.
func (ctx *RetrieveUserContext) OKOwner(r *UserOwner) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *RetrieveUserContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Unauthorized sends a HTTP response with status code 401.
func (ctx *RetrieveUserContext) Unauthorized(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 401, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *RetrieveUserContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RetrieveUserContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// UpdateUserContext provides the user update action context.
type UpdateUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *UserParams
}

// NewUpdateUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller update action.
func NewUpdateUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*UpdateUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := UpdateUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *UpdateUserContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *UpdateUserContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *UpdateUserContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *UpdateUserContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// UpdateAdminUserContext provides the user update-admin action context.
type UpdateAdminUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	UID     *string
	Payload *UserParamsAdmin
}

// NewUpdateAdminUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller update-admin action.
func NewUpdateAdminUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*UpdateAdminUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := UpdateAdminUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramUID := req.Params["uid"]
	if len(paramUID) > 0 {
		rawUID := paramUID[0]
		rctx.UID = &rawUID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *UpdateAdminUserContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "OK")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// Forbidden sends a HTTP response with status code 403.
func (ctx *UpdateAdminUserContext) Forbidden(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 403, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *UpdateAdminUserContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *UpdateAdminUserContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// UpdatePluginPermissionsUserContext provides the user update-plugin-permissions action context.
type UpdatePluginPermissionsUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *UserPlugin
}

// NewUpdatePluginPermissionsUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller update-plugin-permissions action.
func NewUpdatePluginPermissionsUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*UpdatePluginPermissionsUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := UpdatePluginPermissionsUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OKAdmin sends a HTTP response with status code 200.
func (ctx *UpdatePluginPermissionsUserContext) OKAdmin(r *UserAdmin) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OK sends a HTTP response with status code 200.
func (ctx *UpdatePluginPermissionsUserContext) OK(r *User) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKOwner sends a HTTP response with status code 200.
func (ctx *UpdatePluginPermissionsUserContext) OKOwner(r *UserOwner) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *UpdatePluginPermissionsUserContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *UpdatePluginPermissionsUserContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// ValidateEmailUserContext provides the user validate-email action context.
type ValidateEmailUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ValidateID string
}

// NewValidateEmailUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller validate-email action.
func NewValidateEmailUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*ValidateEmailUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ValidateEmailUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramValidateID := req.Params["validateID"]
	if len(paramValidateID) > 0 {
		rawValidateID := paramValidateID[0]
		rctx.ValidateID = rawValidateID
	}
	return &rctx, err
}

// SeeOther sends a HTTP response with status code 303.
func (ctx *ValidateEmailUserContext) SeeOther() error {
	ctx.ResponseData.WriteHeader(303)
	return nil
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ValidateEmailUserContext) NotFound(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/html")
	}
	ctx.ResponseData.WriteHeader(404)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *ValidateEmailUserContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}
