// Code generated by goagen v1.3.1, DO NOT EDIT.
//
// API "user": Application Media Types
//
// Command:
// $ goagen
// --design=gigglesearch.org/giggle-auth/auth/design
// --out=$(GOPATH)/src/gigglesearch.org/giggle-auth/auth
// --version=v1.3.1

package app

import (
	"github.com/goadesign/goa"
	uuid "github.com/gofrs/uuid"
	"time"
)

// All of the sessions associated with a user (default view)
//
// Identifier: all-sessions; view=default
type AllSessions struct {
	CurrentSession *Session          `form:"currentSession,omitempty" json:"currentSession,omitempty" yaml:"currentSession,omitempty" xml:"currentSession,omitempty"`
	OtherSessions  SessionCollection `form:"otherSessions,omitempty" json:"otherSessions,omitempty" yaml:"otherSessions,omitempty" xml:"otherSessions,omitempty"`
}

// Validate validates the AllSessions media type instance.
func (mt *AllSessions) Validate() (err error) {
	if mt.CurrentSession != nil {
		if err2 := mt.CurrentSession.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if err2 := mt.OtherSessions.Validate(); err2 != nil {
		err = goa.MergeErrors(err, err2)
	}
	return
}

// Information used to pre-populate the register page (default view)
//
// Identifier: amazon-register-media; view=default
type AmazonRegisterMedia struct {
	// An email extracted from the Amazon account
	Email string `form:"email" json:"email" yaml:"email" xml:"email"`
	// The given name for the user, pulled from the Amazon account
	FirstName string `form:"firstName" json:"firstName" yaml:"firstName" xml:"firstName"`
	// The family name for the user, pulled from the Amazon account
	LastName string `form:"lastName" json:"lastName" yaml:"lastName" xml:"lastName"`
	// A key used to connect the register request with the specific account
	OauthKey uuid.UUID `form:"oauthKey" json:"oauthKey" yaml:"oauthKey" xml:"oauthKey"`
}

// Validate validates the AmazonRegisterMedia media type instance.
func (mt *AmazonRegisterMedia) Validate() (err error) {
	if mt.Email == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "email"))
	}
	if mt.FirstName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "firstName"))
	}
	if mt.LastName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "lastName"))
	}

	return
}

// If other Oauths or Auths exists on account. (default view)
//
// Identifier: auth-status; view=default
type AuthStatus struct {
	// True if user has facebook Oauth signin
	Facebook bool `form:"facebook" json:"facebook" yaml:"facebook" xml:"facebook"`
	// True if user has google Oauth signin
	Google bool `form:"google" json:"google" yaml:"google" xml:"google"`
	// True if user has linkedin Oauth signin
	Linkedin bool `form:"linkedin" json:"linkedin" yaml:"linkedin" xml:"linkedin"`
	// True if user has microsoft Oauth signin
	Microsoft bool `form:"microsoft" json:"microsoft" yaml:"microsoft" xml:"microsoft"`
	// True if user has password signin
	Standard bool `form:"standard" json:"standard" yaml:"standard" xml:"standard"`
	// True if user has twitter Oauth signin
	Twitter bool `form:"twitter" json:"twitter" yaml:"twitter" xml:"twitter"`
}

// Validate validates the AuthStatus media type instance.
func (mt *AuthStatus) Validate() (err error) {

	return
}

// an individual bookmark (default view)
//
// Identifier: bookmark; view=default
type Bookmark struct {
	// category of the post or video
	Category string `form:"category" json:"category" yaml:"category" xml:"category"`
	// description of the post or video
	Description string `form:"description" json:"description" yaml:"description" xml:"description"`
	// ID of the post or video as per database
	ID string `form:"id" json:"id" yaml:"id" xml:"id"`
	// title of post or video
	Title string `form:"title" json:"title" yaml:"title" xml:"title"`
	// whether this bookmark is a video or a post
	Type string `form:"type" json:"type" yaml:"type" xml:"type"`
}

// Validate validates the Bookmark media type instance.
func (mt *Bookmark) Validate() (err error) {
	if mt.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if mt.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if mt.Title == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "title"))
	}
	if mt.Category == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "category"))
	}
	if mt.Description == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "description"))
	}
	return
}

// Information used to pre-populate the register page (default view)
//
// Identifier: facebook-register-media; view=default
type FacebookRegisterMedia struct {
	// An email extracted from the Facebook account
	Email string `form:"email" json:"email" yaml:"email" xml:"email"`
	// The given name for the user, pulled from the Facebook account
	FirstName string `form:"firstName" json:"firstName" yaml:"firstName" xml:"firstName"`
	// The family name for the user, pulled from the Facebook account
	LastName string `form:"lastName" json:"lastName" yaml:"lastName" xml:"lastName"`
	// A key used to connect the register request with the specific account
	OauthKey uuid.UUID `form:"oauthKey" json:"oauthKey" yaml:"oauthKey" xml:"oauthKey"`
}

// Validate validates the FacebookRegisterMedia media type instance.
func (mt *FacebookRegisterMedia) Validate() (err error) {
	if mt.Email == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "email"))
	}
	if mt.FirstName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "firstName"))
	}
	if mt.LastName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "lastName"))
	}

	return
}

// Information used to pre-populate the register page (default view)
//
// Identifier: google-register-media; view=default
type GoogleRegisterMedia struct {
	// An email extracted from the Google account
	Email string `form:"email" json:"email" yaml:"email" xml:"email"`
	// The given name for the user, pulled from the Google account
	FirstName string `form:"firstName" json:"firstName" yaml:"firstName" xml:"firstName"`
	// The family name for the user, pulled from the Google account
	LastName string `form:"lastName" json:"lastName" yaml:"lastName" xml:"lastName"`
	// A key used to connect the register request with the specific account
	OauthKey uuid.UUID `form:"oauthKey" json:"oauthKey" yaml:"oauthKey" xml:"oauthKey"`
}

// Validate validates the GoogleRegisterMedia media type instance.
func (mt *GoogleRegisterMedia) Validate() (err error) {
	if mt.Email == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "email"))
	}
	if mt.FirstName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "firstName"))
	}
	if mt.LastName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "lastName"))
	}

	return
}

// Information used to pre-populate the register page (default view)
//
// Identifier: linkedin-register-media; view=default
type LinkedinRegisterMedia struct {
	// An email extracted from the Linkedin account
	Email string `form:"email" json:"email" yaml:"email" xml:"email"`
	// The given name for the user, pulled from the Linkedin account
	FirstName string `form:"firstName" json:"firstName" yaml:"firstName" xml:"firstName"`
	// The family name for the user, pulled from the Linkedin account
	LastName string `form:"lastName" json:"lastName" yaml:"lastName" xml:"lastName"`
	// A key used to connect the register request with the specific account
	OauthKey uuid.UUID `form:"oauthKey" json:"oauthKey" yaml:"oauthKey" xml:"oauthKey"`
}

// Validate validates the LinkedinRegisterMedia media type instance.
func (mt *LinkedinRegisterMedia) Validate() (err error) {
	if mt.Email == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "email"))
	}
	if mt.FirstName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "firstName"))
	}
	if mt.LastName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "lastName"))
	}

	return
}

// Information used to pre-populate the register page (default view)
//
// Identifier: microsoft-register-media; view=default
type MicrosoftRegisterMedia struct {
	// An email extracted from the Microsoft account
	Email string `form:"email" json:"email" yaml:"email" xml:"email"`
	// The given name for the user, pulled from the Microsoft account
	FirstName string `form:"firstName" json:"firstName" yaml:"firstName" xml:"firstName"`
	// The family name for the user, pulled from the Microsoft account
	LastName string `form:"lastName" json:"lastName" yaml:"lastName" xml:"lastName"`
	// A key used to connect the register request with the specific account
	OauthKey uuid.UUID `form:"oauthKey" json:"oauthKey" yaml:"oauthKey" xml:"oauthKey"`
}

// Validate validates the MicrosoftRegisterMedia media type instance.
func (mt *MicrosoftRegisterMedia) Validate() (err error) {
	if mt.Email == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "email"))
	}
	if mt.FirstName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "firstName"))
	}
	if mt.LastName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "lastName"))
	}

	return
}

// An individual newsletter subscriber (default view)
//
// Identifier: newsletter-subscriber; view=default
type NewsletterSubscriber struct {
	Email        string    `form:"email" json:"email" yaml:"email" xml:"email"`
	IsActive     bool      `form:"isActive" json:"isActive" yaml:"isActive" xml:"isActive"`
	SubscribedAt time.Time `form:"subscribedAt" json:"subscribedAt" yaml:"subscribedAt" xml:"subscribedAt"`
}

// Validate validates the NewsletterSubscriber media type instance.
func (mt *NewsletterSubscriber) Validate() (err error) {
	if mt.Email == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "email"))
	}

	if err2 := goa.ValidateFormat(goa.FormatEmail, mt.Email); err2 != nil {
		err = goa.MergeErrors(err, goa.InvalidFormatError(`response.email`, mt.Email, goa.FormatEmail, err2))
	}
	return
}

// Newsletter-SubscriberCollection is the media type for an array of Newsletter-Subscriber (default view)
//
// Identifier: newsletter-subscriber; type=collection; view=default
type NewsletterSubscriberCollection []*NewsletterSubscriber

// Validate validates the NewsletterSubscriberCollection media type instance.
func (mt NewsletterSubscriberCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// A session for a user, associated with a specific browser (default view)
//
// Identifier: session; view=default
type Session struct {
	// The browser and browser version connected with this session
	Browser string `form:"browser" json:"browser" yaml:"browser" xml:"browser"`
	// The latitude and longitude of the last known location of the session
	Coordinates string `form:"coordinates" json:"coordinates" yaml:"coordinates" xml:"coordinates"`
	// Unique unchanging session ID
	ID string `form:"id" json:"id" yaml:"id" xml:"id"`
	// The last IP address where this session was used
	IP string `form:"ip" json:"ip" yaml:"ip" xml:"ip"`
	// Whether the session was from a mobile device
	IsMobile bool `form:"isMobile" json:"isMobile" yaml:"isMobile" xml:"isMobile"`
	// Time that this session was last used
	LastUsed time.Time `form:"lastUsed" json:"lastUsed" yaml:"lastUsed" xml:"lastUsed"`
	// A humanReadable string describing the last known location of the session
	Location string `form:"location" json:"location" yaml:"location" xml:"location"`
	// The URL of the Google map to show the location, suitable for using in an img tag
	MapURL string `form:"mapUrl" json:"mapUrl" yaml:"mapUrl" xml:"mapUrl"`
	// The OS of the system where this session was used
	Os string `form:"os" json:"os" yaml:"os" xml:"os"`
	// ID of the user this session is for
	UserID string `form:"userId" json:"userId" yaml:"userId" xml:"userId"`
}

// Validate validates the Session media type instance.
func (mt *Session) Validate() (err error) {
	if mt.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if mt.UserID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "userId"))
	}

	if mt.Browser == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "browser"))
	}
	if mt.Os == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "os"))
	}
	if mt.IP == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "ip"))
	}
	if mt.Location == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "location"))
	}
	if mt.Coordinates == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "coordinates"))
	}

	if mt.MapURL == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "mapUrl"))
	}
	return
}

// SessionCollection is the media type for an array of Session (default view)
//
// Identifier: session; type=collection; view=default
type SessionCollection []*Session

// Validate validates the SessionCollection media type instance.
func (mt SessionCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// Information used to pre-populate the register page (default view)
//
// Identifier: twitter-register-media; view=default
type TwitterRegisterMedia struct {
	// An email extracted from the Twitter account
	Email string `form:"email" json:"email" yaml:"email" xml:"email"`
	// The given name for the user, pulled from the Twitter account
	FirstName string `form:"firstName" json:"firstName" yaml:"firstName" xml:"firstName"`
	// The family name for the user, pulled from the Twitter account
	LastName string `form:"lastName" json:"lastName" yaml:"lastName" xml:"lastName"`
	// A key used to connect the register request with the specific account
	OauthKey uuid.UUID `form:"oauthKey" json:"oauthKey" yaml:"oauthKey" xml:"oauthKey"`
}

// Validate validates the TwitterRegisterMedia media type instance.
func (mt *TwitterRegisterMedia) Validate() (err error) {
	if mt.Email == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "email"))
	}
	if mt.FirstName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "firstName"))
	}
	if mt.LastName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "lastName"))
	}

	return
}

// A user in the system (admin view)
//
// Identifier: user; view=admin
type UserAdmin struct {
	// Category/Categories that a user might select (User interests)
	Category []string `form:"category,omitempty" json:"category,omitempty" yaml:"category,omitempty" xml:"category,omitempty"`
	// When the user attempts to change their email, this is what they will change it to after they verify that it belongs to them
	ChangingEmail *string `form:"changingEmail,omitempty" json:"changingEmail,omitempty" yaml:"changingEmail,omitempty" xml:"changingEmail,omitempty"`
	// Email attached to the account of the user
	Email string `form:"email" json:"email" yaml:"email" xml:"email"`
	// Given name for the user
	FirstName string `form:"firstName" json:"firstName" yaml:"firstName" xml:"firstName"`
	Gender    string `form:"gender" json:"gender" yaml:"gender" xml:"gender"`
	// True if the user wants to receive the newsletter
	GetNewsletter bool `form:"getNewsletter" json:"getNewsletter" yaml:"getNewsletter" xml:"getNewsletter"`
	// Unique unchanging user ID
	ID string `form:"id" json:"id" yaml:"id" xml:"id"`
	// Whether the user is an administrator on the site
	IsAdmin bool `form:"isAdmin" json:"isAdmin" yaml:"isAdmin" xml:"isAdmin"`
	// Whether the user is a event author on the site
	IsEventAuthor *bool `form:"isEventAuthor,omitempty" json:"isEventAuthor,omitempty" yaml:"isEventAuthor,omitempty" xml:"isEventAuthor,omitempty"`
	// Whether the user is a plugin author on the site
	IsPluginAuthor bool `form:"isPluginAuthor" json:"isPluginAuthor" yaml:"isPluginAuthor" xml:"isPluginAuthor"`
	// Family name for the user
	LastName string `form:"lastName" json:"lastName" yaml:"lastName" xml:"lastName"`
	// Phone Number Of the user
	Phone string `form:"phone" json:"phone" yaml:"phone" xml:"phone"`
	// IDs of all plugins that the user has installed
	Plugins      []*UserPluginMedia `form:"plugins,omitempty" json:"plugins,omitempty" yaml:"plugins,omitempty" xml:"plugins,omitempty"`
	ProfileImage string             `form:"profileImage" json:"profileImage" yaml:"profileImage" xml:"profileImage"`
	// Whether the user has verified their email
	VerifiedEmail bool `form:"verifiedEmail" json:"verifiedEmail" yaml:"verifiedEmail" xml:"verifiedEmail"`
}

// Validate validates the UserAdmin media type instance.
func (mt *UserAdmin) Validate() (err error) {
	if mt.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if mt.Email == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "email"))
	}
	if mt.Phone == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "phone"))
	}

	if mt.FirstName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "firstName"))
	}
	if mt.LastName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "lastName"))
	}

	if mt.ProfileImage == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "profileImage"))
	}
	if mt.Gender == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "gender"))
	}
	for _, e := range mt.Plugins {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// A user in the system (default view)
//
// Identifier: user; view=default
type User struct {
	// Category/Categories that a user might select (User interests)
	Category []string `form:"category,omitempty" json:"category,omitempty" yaml:"category,omitempty" xml:"category,omitempty"`
	// Given name for the user
	FirstName string `form:"firstName" json:"firstName" yaml:"firstName" xml:"firstName"`
	// Unique unchanging user ID
	ID string `form:"id" json:"id" yaml:"id" xml:"id"`
	// Whether the user is a event author on the site
	IsEventAuthor *bool `form:"isEventAuthor,omitempty" json:"isEventAuthor,omitempty" yaml:"isEventAuthor,omitempty" xml:"isEventAuthor,omitempty"`
	// Whether the user is a plugin author on the site
	IsPluginAuthor bool `form:"isPluginAuthor" json:"isPluginAuthor" yaml:"isPluginAuthor" xml:"isPluginAuthor"`
	// Family name for the user
	LastName string `form:"lastName" json:"lastName" yaml:"lastName" xml:"lastName"`
	// IDs of all plugins that the user has installed
	Plugins      []*UserPluginMedia `form:"plugins,omitempty" json:"plugins,omitempty" yaml:"plugins,omitempty" xml:"plugins,omitempty"`
	ProfileImage string             `form:"profileImage" json:"profileImage" yaml:"profileImage" xml:"profileImage"`
}

// Validate validates the User media type instance.
func (mt *User) Validate() (err error) {
	if mt.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}

	if mt.FirstName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "firstName"))
	}
	if mt.LastName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "lastName"))
	}
	if mt.ProfileImage == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "profileImage"))
	}
	for _, e := range mt.Plugins {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// A user in the system (owner view)
//
// Identifier: user; view=owner
type UserOwner struct {
	// Category/Categories that a user might select (User interests)
	Category []string `form:"category,omitempty" json:"category,omitempty" yaml:"category,omitempty" xml:"category,omitempty"`
	// When the user attempts to change their email, this is what they will change it to after they verify that it belongs to them
	ChangingEmail *string `form:"changingEmail,omitempty" json:"changingEmail,omitempty" yaml:"changingEmail,omitempty" xml:"changingEmail,omitempty"`
	// Email attached to the account of the user
	Email string `form:"email" json:"email" yaml:"email" xml:"email"`
	// Given name for the user
	FirstName string `form:"firstName" json:"firstName" yaml:"firstName" xml:"firstName"`
	Gender    string `form:"gender" json:"gender" yaml:"gender" xml:"gender"`
	// True if the user wants to receive the newsletter
	GetNewsletter bool `form:"getNewsletter" json:"getNewsletter" yaml:"getNewsletter" xml:"getNewsletter"`
	// Unique unchanging user ID
	ID string `form:"id" json:"id" yaml:"id" xml:"id"`
	// Whether the user is a event author on the site
	IsEventAuthor *bool `form:"isEventAuthor,omitempty" json:"isEventAuthor,omitempty" yaml:"isEventAuthor,omitempty" xml:"isEventAuthor,omitempty"`
	// Whether the user is a plugin author on the site
	IsPluginAuthor bool `form:"isPluginAuthor" json:"isPluginAuthor" yaml:"isPluginAuthor" xml:"isPluginAuthor"`
	// Family name for the user
	LastName string `form:"lastName" json:"lastName" yaml:"lastName" xml:"lastName"`
	// Phone Number Of the user
	Phone string `form:"phone" json:"phone" yaml:"phone" xml:"phone"`
	// IDs of all plugins that the user has installed
	Plugins      []*UserPluginMedia `form:"plugins,omitempty" json:"plugins,omitempty" yaml:"plugins,omitempty" xml:"plugins,omitempty"`
	ProfileImage string             `form:"profileImage" json:"profileImage" yaml:"profileImage" xml:"profileImage"`
	// Whether the user has verified their email
	VerifiedEmail bool `form:"verifiedEmail" json:"verifiedEmail" yaml:"verifiedEmail" xml:"verifiedEmail"`
}

// Validate validates the UserOwner media type instance.
func (mt *UserOwner) Validate() (err error) {
	if mt.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if mt.Email == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "email"))
	}
	if mt.Phone == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "phone"))
	}

	if mt.FirstName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "firstName"))
	}
	if mt.LastName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "lastName"))
	}

	if mt.ProfileImage == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "profileImage"))
	}
	if mt.Gender == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "gender"))
	}
	for _, e := range mt.Plugins {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// Details about all the plugins that user has installed (default view)
//
// Identifier: user-plugin-media; view=default
type UserPluginMedia struct {
	DateAdded          time.Time `form:"dateAdded" json:"dateAdded" yaml:"dateAdded" xml:"dateAdded"`
	PermissionsAllowed []string  `form:"permissionsAllowed" json:"permissionsAllowed" yaml:"permissionsAllowed" xml:"permissionsAllowed"`
	PluginID           string    `form:"pluginID" json:"pluginID" yaml:"pluginID" xml:"pluginID"`
}

// Validate validates the UserPluginMedia media type instance.
func (mt *UserPluginMedia) Validate() (err error) {
	if mt.PluginID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "pluginID"))
	}
	if mt.PermissionsAllowed == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "permissionsAllowed"))
	}

	return
}

// UserCollection is the media type for an array of User (admin view)
//
// Identifier: user; type=collection; view=admin
type UserAdminCollection []*UserAdmin

// Validate validates the UserAdminCollection media type instance.
func (mt UserAdminCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// UserCollection is the media type for an array of User (default view)
//
// Identifier: user; type=collection; view=default
type UserCollection []*User

// Validate validates the UserCollection media type instance.
func (mt UserCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// UserCollection is the media type for an array of User (owner view)
//
// Identifier: user; type=collection; view=owner
type UserOwnerCollection []*UserOwner

// Validate validates the UserOwnerCollection media type instance.
func (mt UserOwnerCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}
