// Code generated by goagen v1.3.1, DO NOT EDIT.
//
// API "user": Application Controllers
//
// Command:
// $ goagen
// --design=gigglesearch.org/giggle-auth/auth/design
// --out=$(GOPATH)/src/gigglesearch.org/giggle-auth/auth
// --version=v1.3.1

package app

import (
	"context"
	"github.com/goadesign/goa"
	"github.com/goadesign/goa/cors"
	"net/http"
)

// initService sets up the service encoders, decoders and mux.
func initService(service *goa.Service) {
	// Setup encoders and decoders
	service.Encoder.Register(goa.NewJSONEncoder, "application/json")
	service.Encoder.Register(goa.NewGobEncoder, "application/gob", "application/x-gob")
	service.Encoder.Register(goa.NewXMLEncoder, "application/xml")
	service.Decoder.Register(goa.NewJSONDecoder, "application/json")
	service.Decoder.Register(goa.NewGobDecoder, "application/gob", "application/x-gob")
	service.Decoder.Register(goa.NewXMLDecoder, "application/xml")

	// Setup default encoder and decoder
	service.Encoder.Register(goa.NewJSONEncoder, "*/*")
	service.Decoder.Register(goa.NewJSONDecoder, "*/*")
}

// AmazonController is the controller interface for the Amazon actions.
type AmazonController interface {
	goa.Muxer
	AttachToAccount(*AttachToAccountAmazonContext) error
	DetachFromAccount(*DetachFromAccountAmazonContext) error
	Login(*LoginAmazonContext) error
	Receive(*ReceiveAmazonContext) error
	Register(*RegisterAmazonContext) error
	RegisterURL(*RegisterURLAmazonContext) error
}

// MountAmazonController "mounts" a Amazon resource controller on the given service.
func MountAmazonController(service *goa.Service, ctrl AmazonController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/amazon/attach", ctrl.MuxHandler("preflight", handleAmazonOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/amazon/detach", ctrl.MuxHandler("preflight", handleAmazonOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/amazon/login", ctrl.MuxHandler("preflight", handleAmazonOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/amazon/receive", ctrl.MuxHandler("preflight", handleAmazonOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/amazon/register", ctrl.MuxHandler("preflight", handleAmazonOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/amazon/register-start", ctrl.MuxHandler("preflight", handleAmazonOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewAttachToAccountAmazonContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.AttachToAccount(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleAmazonOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/amazon/attach", ctrl.MuxHandler("attach-to-account", h, nil))
	service.LogInfo("mount", "ctrl", "Amazon", "action", "AttachToAccount", "route", "POST /api/v1/user/auth/amazon/attach", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewDetachFromAccountAmazonContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.DetachFromAccount(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleAmazonOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/amazon/detach", ctrl.MuxHandler("detach-from-account", h, nil))
	service.LogInfo("mount", "ctrl", "Amazon", "action", "DetachFromAccount", "route", "POST /api/v1/user/auth/amazon/detach", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewLoginAmazonContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Login(rctx)
	}
	h = handleSecurity("key", h)
	h = handleAmazonOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/amazon/login", ctrl.MuxHandler("login", h, nil))
	service.LogInfo("mount", "ctrl", "Amazon", "action", "Login", "route", "GET /api/v1/user/auth/amazon/login", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewReceiveAmazonContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Receive(rctx)
	}
	h = handleSecurity("key", h)
	h = handleAmazonOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/amazon/receive", ctrl.MuxHandler("receive", h, nil))
	service.LogInfo("mount", "ctrl", "Amazon", "action", "Receive", "route", "GET /api/v1/user/auth/amazon/receive", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewRegisterAmazonContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*AmazonRegisterParams)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Register(rctx)
	}
	h = handleSecurity("key", h)
	h = handleAmazonOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/amazon/register", ctrl.MuxHandler("register", h, unmarshalRegisterAmazonPayload))
	service.LogInfo("mount", "ctrl", "Amazon", "action", "Register", "route", "POST /api/v1/user/auth/amazon/register", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewRegisterURLAmazonContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.RegisterURL(rctx)
	}
	h = handleSecurity("key", h)
	h = handleAmazonOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/amazon/register-start", ctrl.MuxHandler("register-url", h, nil))
	service.LogInfo("mount", "ctrl", "Amazon", "action", "RegisterURL", "route", "GET /api/v1/user/auth/amazon/register-start", "security", "key")
}

// handleAmazonOrigin applies the CORS response headers corresponding to the origin.
func handleAmazonOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, PATCH, DELETE, OPTIONS")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalRegisterAmazonPayload unmarshals the request body into the context request data Payload field.
func unmarshalRegisterAmazonPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &amazonRegisterParams{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// BookmarkController is the controller interface for the Bookmark actions.
type BookmarkController interface {
	goa.Muxer
	AddPost(*AddPostBookmarkContext) error
	AddVideo(*AddVideoBookmarkContext) error
	GetBookmarks(*GetBookmarksBookmarkContext) error
	GetPostBookmarks(*GetPostBookmarksBookmarkContext) error
	GetVideoBookmarks(*GetVideoBookmarksBookmarkContext) error
	RemoveFromBookmark(*RemoveFromBookmarkBookmarkContext) error
}

// MountBookmarkController "mounts" a Bookmark resource controller on the given service.
func MountBookmarkController(service *goa.Service, ctrl BookmarkController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/user/bookmark/post", ctrl.MuxHandler("preflight", handleBookmarkOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/bookmark/video", ctrl.MuxHandler("preflight", handleBookmarkOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/bookmark", ctrl.MuxHandler("preflight", handleBookmarkOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewAddPostBookmarkContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*BookmarkParams)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.AddPost(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleBookmarkOrigin(h)
	service.Mux.Handle("PUT", "/api/v1/user/bookmark/post", ctrl.MuxHandler("addPost", h, unmarshalAddPostBookmarkPayload))
	service.LogInfo("mount", "ctrl", "Bookmark", "action", "AddPost", "route", "PUT /api/v1/user/bookmark/post", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewAddVideoBookmarkContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*BookmarkParams)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.AddVideo(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleBookmarkOrigin(h)
	service.Mux.Handle("PUT", "/api/v1/user/bookmark/video", ctrl.MuxHandler("addVideo", h, unmarshalAddVideoBookmarkPayload))
	service.LogInfo("mount", "ctrl", "Bookmark", "action", "AddVideo", "route", "PUT /api/v1/user/bookmark/video", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewGetBookmarksBookmarkContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.GetBookmarks(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleBookmarkOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/bookmark", ctrl.MuxHandler("getBookmarks", h, nil))
	service.LogInfo("mount", "ctrl", "Bookmark", "action", "GetBookmarks", "route", "GET /api/v1/user/bookmark", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewGetPostBookmarksBookmarkContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.GetPostBookmarks(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleBookmarkOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/bookmark/post", ctrl.MuxHandler("getPostBookmarks", h, nil))
	service.LogInfo("mount", "ctrl", "Bookmark", "action", "GetPostBookmarks", "route", "GET /api/v1/user/bookmark/post", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewGetVideoBookmarksBookmarkContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.GetVideoBookmarks(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleBookmarkOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/bookmark/video", ctrl.MuxHandler("getVideoBookmarks", h, nil))
	service.LogInfo("mount", "ctrl", "Bookmark", "action", "GetVideoBookmarks", "route", "GET /api/v1/user/bookmark/video", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewRemoveFromBookmarkBookmarkContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.RemoveFromBookmark(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleBookmarkOrigin(h)
	service.Mux.Handle("DELETE", "/api/v1/user/bookmark", ctrl.MuxHandler("removeFromBookmark", h, nil))
	service.LogInfo("mount", "ctrl", "Bookmark", "action", "RemoveFromBookmark", "route", "DELETE /api/v1/user/bookmark", "security", "jwt")
}

// handleBookmarkOrigin applies the CORS response headers corresponding to the origin.
func handleBookmarkOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, PATCH, DELETE, OPTIONS")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalAddPostBookmarkPayload unmarshals the request body into the context request data Payload field.
func unmarshalAddPostBookmarkPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &bookmarkParams{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// unmarshalAddVideoBookmarkPayload unmarshals the request body into the context request data Payload field.
func unmarshalAddVideoBookmarkPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &bookmarkParams{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// FacebookController is the controller interface for the Facebook actions.
type FacebookController interface {
	goa.Muxer
	AttachToAccount(*AttachToAccountFacebookContext) error
	DetachFromAccount(*DetachFromAccountFacebookContext) error
	Login(*LoginFacebookContext) error
	Receive(*ReceiveFacebookContext) error
	Register(*RegisterFacebookContext) error
	RegisterURL(*RegisterURLFacebookContext) error
}

// MountFacebookController "mounts" a Facebook resource controller on the given service.
func MountFacebookController(service *goa.Service, ctrl FacebookController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/facebook/attach", ctrl.MuxHandler("preflight", handleFacebookOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/facebook/detach", ctrl.MuxHandler("preflight", handleFacebookOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/facebook/login", ctrl.MuxHandler("preflight", handleFacebookOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/facebook/receive", ctrl.MuxHandler("preflight", handleFacebookOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/facebook/register", ctrl.MuxHandler("preflight", handleFacebookOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/facebook/register-start", ctrl.MuxHandler("preflight", handleFacebookOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewAttachToAccountFacebookContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.AttachToAccount(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleFacebookOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/facebook/attach", ctrl.MuxHandler("attach-to-account", h, nil))
	service.LogInfo("mount", "ctrl", "Facebook", "action", "AttachToAccount", "route", "POST /api/v1/user/auth/facebook/attach", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewDetachFromAccountFacebookContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.DetachFromAccount(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleFacebookOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/facebook/detach", ctrl.MuxHandler("detach-from-account", h, nil))
	service.LogInfo("mount", "ctrl", "Facebook", "action", "DetachFromAccount", "route", "POST /api/v1/user/auth/facebook/detach", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewLoginFacebookContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Login(rctx)
	}
	h = handleSecurity("key", h)
	h = handleFacebookOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/facebook/login", ctrl.MuxHandler("login", h, nil))
	service.LogInfo("mount", "ctrl", "Facebook", "action", "Login", "route", "GET /api/v1/user/auth/facebook/login", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewReceiveFacebookContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Receive(rctx)
	}
	h = handleSecurity("key", h)
	h = handleFacebookOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/facebook/receive", ctrl.MuxHandler("receive", h, nil))
	service.LogInfo("mount", "ctrl", "Facebook", "action", "Receive", "route", "GET /api/v1/user/auth/facebook/receive", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewRegisterFacebookContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*FacebookRegisterParams)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Register(rctx)
	}
	h = handleSecurity("key", h)
	h = handleFacebookOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/facebook/register", ctrl.MuxHandler("register", h, unmarshalRegisterFacebookPayload))
	service.LogInfo("mount", "ctrl", "Facebook", "action", "Register", "route", "POST /api/v1/user/auth/facebook/register", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewRegisterURLFacebookContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.RegisterURL(rctx)
	}
	h = handleSecurity("key", h)
	h = handleFacebookOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/facebook/register-start", ctrl.MuxHandler("register-url", h, nil))
	service.LogInfo("mount", "ctrl", "Facebook", "action", "RegisterURL", "route", "GET /api/v1/user/auth/facebook/register-start", "security", "key")
}

// handleFacebookOrigin applies the CORS response headers corresponding to the origin.
func handleFacebookOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, PATCH, DELETE, OPTIONS")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalRegisterFacebookPayload unmarshals the request body into the context request data Payload field.
func unmarshalRegisterFacebookPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &facebookRegisterParams{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// GoogleController is the controller interface for the Google actions.
type GoogleController interface {
	goa.Muxer
	AttachToAccount(*AttachToAccountGoogleContext) error
	DetachFromAccount(*DetachFromAccountGoogleContext) error
	Login(*LoginGoogleContext) error
	Receive(*ReceiveGoogleContext) error
	Register(*RegisterGoogleContext) error
	RegisterURL(*RegisterURLGoogleContext) error
}

// MountGoogleController "mounts" a Google resource controller on the given service.
func MountGoogleController(service *goa.Service, ctrl GoogleController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/google/attach", ctrl.MuxHandler("preflight", handleGoogleOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/google/detach", ctrl.MuxHandler("preflight", handleGoogleOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/google/login", ctrl.MuxHandler("preflight", handleGoogleOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/google/receive", ctrl.MuxHandler("preflight", handleGoogleOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/google/register", ctrl.MuxHandler("preflight", handleGoogleOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/google/register-start", ctrl.MuxHandler("preflight", handleGoogleOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewAttachToAccountGoogleContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.AttachToAccount(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleGoogleOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/google/attach", ctrl.MuxHandler("attach-to-account", h, nil))
	service.LogInfo("mount", "ctrl", "Google", "action", "AttachToAccount", "route", "POST /api/v1/user/auth/google/attach", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewDetachFromAccountGoogleContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.DetachFromAccount(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleGoogleOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/google/detach", ctrl.MuxHandler("detach-from-account", h, nil))
	service.LogInfo("mount", "ctrl", "Google", "action", "DetachFromAccount", "route", "POST /api/v1/user/auth/google/detach", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewLoginGoogleContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Login(rctx)
	}
	h = handleSecurity("key", h)
	h = handleGoogleOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/google/login", ctrl.MuxHandler("login", h, nil))
	service.LogInfo("mount", "ctrl", "Google", "action", "Login", "route", "GET /api/v1/user/auth/google/login", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewReceiveGoogleContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Receive(rctx)
	}
	h = handleSecurity("key", h)
	h = handleGoogleOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/google/receive", ctrl.MuxHandler("receive", h, nil))
	service.LogInfo("mount", "ctrl", "Google", "action", "Receive", "route", "GET /api/v1/user/auth/google/receive", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewRegisterGoogleContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*GoogleRegisterParams)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Register(rctx)
	}
	h = handleSecurity("key", h)
	h = handleGoogleOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/google/register", ctrl.MuxHandler("register", h, unmarshalRegisterGooglePayload))
	service.LogInfo("mount", "ctrl", "Google", "action", "Register", "route", "POST /api/v1/user/auth/google/register", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewRegisterURLGoogleContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.RegisterURL(rctx)
	}
	h = handleSecurity("key", h)
	h = handleGoogleOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/google/register-start", ctrl.MuxHandler("register-url", h, nil))
	service.LogInfo("mount", "ctrl", "Google", "action", "RegisterURL", "route", "GET /api/v1/user/auth/google/register-start", "security", "key")
}

// handleGoogleOrigin applies the CORS response headers corresponding to the origin.
func handleGoogleOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, PATCH, DELETE, OPTIONS")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalRegisterGooglePayload unmarshals the request body into the context request data Payload field.
func unmarshalRegisterGooglePayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &googleRegisterParams{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// LinkedinController is the controller interface for the Linkedin actions.
type LinkedinController interface {
	goa.Muxer
	AttachToAccount(*AttachToAccountLinkedinContext) error
	DetachFromAccount(*DetachFromAccountLinkedinContext) error
	Login(*LoginLinkedinContext) error
	Receive(*ReceiveLinkedinContext) error
	Register(*RegisterLinkedinContext) error
	RegisterURL(*RegisterURLLinkedinContext) error
}

// MountLinkedinController "mounts" a Linkedin resource controller on the given service.
func MountLinkedinController(service *goa.Service, ctrl LinkedinController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/linkedin/attach", ctrl.MuxHandler("preflight", handleLinkedinOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/linkedin/detach", ctrl.MuxHandler("preflight", handleLinkedinOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/linkedin/login", ctrl.MuxHandler("preflight", handleLinkedinOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/linkedin/receive", ctrl.MuxHandler("preflight", handleLinkedinOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/linkedin/register", ctrl.MuxHandler("preflight", handleLinkedinOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/linkedin/register-start", ctrl.MuxHandler("preflight", handleLinkedinOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewAttachToAccountLinkedinContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.AttachToAccount(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleLinkedinOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/linkedin/attach", ctrl.MuxHandler("attach-to-account", h, nil))
	service.LogInfo("mount", "ctrl", "Linkedin", "action", "AttachToAccount", "route", "POST /api/v1/user/auth/linkedin/attach", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewDetachFromAccountLinkedinContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.DetachFromAccount(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleLinkedinOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/linkedin/detach", ctrl.MuxHandler("detach-from-account", h, nil))
	service.LogInfo("mount", "ctrl", "Linkedin", "action", "DetachFromAccount", "route", "POST /api/v1/user/auth/linkedin/detach", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewLoginLinkedinContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Login(rctx)
	}
	h = handleSecurity("key", h)
	h = handleLinkedinOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/linkedin/login", ctrl.MuxHandler("login", h, nil))
	service.LogInfo("mount", "ctrl", "Linkedin", "action", "Login", "route", "GET /api/v1/user/auth/linkedin/login", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewReceiveLinkedinContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Receive(rctx)
	}
	h = handleSecurity("key", h)
	h = handleLinkedinOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/linkedin/receive", ctrl.MuxHandler("receive", h, nil))
	service.LogInfo("mount", "ctrl", "Linkedin", "action", "Receive", "route", "GET /api/v1/user/auth/linkedin/receive", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewRegisterLinkedinContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*LinkedinRegisterParams)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Register(rctx)
	}
	h = handleSecurity("key", h)
	h = handleLinkedinOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/linkedin/register", ctrl.MuxHandler("register", h, unmarshalRegisterLinkedinPayload))
	service.LogInfo("mount", "ctrl", "Linkedin", "action", "Register", "route", "POST /api/v1/user/auth/linkedin/register", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewRegisterURLLinkedinContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.RegisterURL(rctx)
	}
	h = handleSecurity("key", h)
	h = handleLinkedinOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/linkedin/register-start", ctrl.MuxHandler("register-url", h, nil))
	service.LogInfo("mount", "ctrl", "Linkedin", "action", "RegisterURL", "route", "GET /api/v1/user/auth/linkedin/register-start", "security", "key")
}

// handleLinkedinOrigin applies the CORS response headers corresponding to the origin.
func handleLinkedinOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, PATCH, DELETE, OPTIONS")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalRegisterLinkedinPayload unmarshals the request body into the context request data Payload field.
func unmarshalRegisterLinkedinPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &linkedinRegisterParams{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// MicrosoftController is the controller interface for the Microsoft actions.
type MicrosoftController interface {
	goa.Muxer
	AttachToAccount(*AttachToAccountMicrosoftContext) error
	DetachFromAccount(*DetachFromAccountMicrosoftContext) error
	Login(*LoginMicrosoftContext) error
	Receive(*ReceiveMicrosoftContext) error
	Register(*RegisterMicrosoftContext) error
	RegisterURL(*RegisterURLMicrosoftContext) error
}

// MountMicrosoftController "mounts" a Microsoft resource controller on the given service.
func MountMicrosoftController(service *goa.Service, ctrl MicrosoftController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/microsoft/attach", ctrl.MuxHandler("preflight", handleMicrosoftOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/microsoft/detach", ctrl.MuxHandler("preflight", handleMicrosoftOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/microsoft/login", ctrl.MuxHandler("preflight", handleMicrosoftOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/microsoft/receive", ctrl.MuxHandler("preflight", handleMicrosoftOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/microsoft/register", ctrl.MuxHandler("preflight", handleMicrosoftOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/microsoft/register-start", ctrl.MuxHandler("preflight", handleMicrosoftOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewAttachToAccountMicrosoftContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.AttachToAccount(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleMicrosoftOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/microsoft/attach", ctrl.MuxHandler("attach-to-account", h, nil))
	service.LogInfo("mount", "ctrl", "Microsoft", "action", "AttachToAccount", "route", "POST /api/v1/user/auth/microsoft/attach", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewDetachFromAccountMicrosoftContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.DetachFromAccount(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleMicrosoftOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/microsoft/detach", ctrl.MuxHandler("detach-from-account", h, nil))
	service.LogInfo("mount", "ctrl", "Microsoft", "action", "DetachFromAccount", "route", "POST /api/v1/user/auth/microsoft/detach", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewLoginMicrosoftContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Login(rctx)
	}
	h = handleSecurity("key", h)
	h = handleMicrosoftOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/microsoft/login", ctrl.MuxHandler("login", h, nil))
	service.LogInfo("mount", "ctrl", "Microsoft", "action", "Login", "route", "GET /api/v1/user/auth/microsoft/login", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewReceiveMicrosoftContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Receive(rctx)
	}
	h = handleSecurity("key", h)
	h = handleMicrosoftOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/microsoft/receive", ctrl.MuxHandler("receive", h, nil))
	service.LogInfo("mount", "ctrl", "Microsoft", "action", "Receive", "route", "GET /api/v1/user/auth/microsoft/receive", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewRegisterMicrosoftContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*MicrosoftRegisterParams)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Register(rctx)
	}
	h = handleSecurity("key", h)
	h = handleMicrosoftOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/microsoft/register", ctrl.MuxHandler("register", h, unmarshalRegisterMicrosoftPayload))
	service.LogInfo("mount", "ctrl", "Microsoft", "action", "Register", "route", "POST /api/v1/user/auth/microsoft/register", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewRegisterURLMicrosoftContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.RegisterURL(rctx)
	}
	h = handleSecurity("key", h)
	h = handleMicrosoftOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/microsoft/register-start", ctrl.MuxHandler("register-url", h, nil))
	service.LogInfo("mount", "ctrl", "Microsoft", "action", "RegisterURL", "route", "GET /api/v1/user/auth/microsoft/register-start", "security", "key")
}

// handleMicrosoftOrigin applies the CORS response headers corresponding to the origin.
func handleMicrosoftOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, PATCH, DELETE, OPTIONS")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalRegisterMicrosoftPayload unmarshals the request body into the context request data Payload field.
func unmarshalRegisterMicrosoftPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &microsoftRegisterParams{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// NewsletterController is the controller interface for the Newsletter actions.
type NewsletterController interface {
	goa.Muxer
	AddSubscriber(*AddSubscriberNewsletterContext) error
	GetSubscriberByEmail(*GetSubscriberByEmailNewsletterContext) error
	GetSubscribers(*GetSubscribersNewsletterContext) error
	RemoveSubscriber(*RemoveSubscriberNewsletterContext) error
	UpdateSubscriber(*UpdateSubscriberNewsletterContext) error
}

// MountNewsletterController "mounts" a Newsletter resource controller on the given service.
func MountNewsletterController(service *goa.Service, ctrl NewsletterController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/user/newsletter", ctrl.MuxHandler("preflight", handleNewsletterOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/newsletter/all", ctrl.MuxHandler("preflight", handleNewsletterOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewAddSubscriberNewsletterContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*NewsletterParam)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.AddSubscriber(rctx)
	}
	h = handleSecurity("key", h)
	h = handleNewsletterOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/newsletter", ctrl.MuxHandler("add-subscriber", h, unmarshalAddSubscriberNewsletterPayload))
	service.LogInfo("mount", "ctrl", "Newsletter", "action", "AddSubscriber", "route", "POST /api/v1/user/newsletter", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewGetSubscriberByEmailNewsletterContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.GetSubscriberByEmail(rctx)
	}
	h = handleSecurity("key", h)
	h = handleNewsletterOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/newsletter", ctrl.MuxHandler("get-subscriber-by-email", h, nil))
	service.LogInfo("mount", "ctrl", "Newsletter", "action", "GetSubscriberByEmail", "route", "GET /api/v1/user/newsletter", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewGetSubscribersNewsletterContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.GetSubscribers(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleNewsletterOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/newsletter/all", ctrl.MuxHandler("get-subscribers", h, nil))
	service.LogInfo("mount", "ctrl", "Newsletter", "action", "GetSubscribers", "route", "GET /api/v1/user/newsletter/all", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewRemoveSubscriberNewsletterContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.RemoveSubscriber(rctx)
	}
	h = handleSecurity("key", h)
	h = handleNewsletterOrigin(h)
	service.Mux.Handle("DELETE", "/api/v1/user/newsletter", ctrl.MuxHandler("remove-subscriber", h, nil))
	service.LogInfo("mount", "ctrl", "Newsletter", "action", "RemoveSubscriber", "route", "DELETE /api/v1/user/newsletter", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewUpdateSubscriberNewsletterContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*NewsletterParam)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.UpdateSubscriber(rctx)
	}
	h = handleSecurity("key", h)
	h = handleNewsletterOrigin(h)
	service.Mux.Handle("PATCH", "/api/v1/user/newsletter", ctrl.MuxHandler("update-subscriber", h, unmarshalUpdateSubscriberNewsletterPayload))
	service.LogInfo("mount", "ctrl", "Newsletter", "action", "UpdateSubscriber", "route", "PATCH /api/v1/user/newsletter", "security", "key")
}

// handleNewsletterOrigin applies the CORS response headers corresponding to the origin.
func handleNewsletterOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, PATCH, DELETE, OPTIONS")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalAddSubscriberNewsletterPayload unmarshals the request body into the context request data Payload field.
func unmarshalAddSubscriberNewsletterPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &newsletterParam{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// unmarshalUpdateSubscriberNewsletterPayload unmarshals the request body into the context request data Payload field.
func unmarshalUpdateSubscriberNewsletterPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &newsletterParam{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// PasswordAuthController is the controller interface for the PasswordAuth actions.
type PasswordAuthController interface {
	goa.Muxer
	ChangePassword(*ChangePasswordPasswordAuthContext) error
	ConfirmReset(*ConfirmResetPasswordAuthContext) error
	Login(*LoginPasswordAuthContext) error
	Register(*RegisterPasswordAuthContext) error
	Remove(*RemovePasswordAuthContext) error
	Reset(*ResetPasswordAuthContext) error
}

// MountPasswordAuthController "mounts" a PasswordAuth resource controller on the given service.
func MountPasswordAuthController(service *goa.Service, ctrl PasswordAuthController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/change-password", ctrl.MuxHandler("preflight", handlePasswordAuthOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/finalize-reset", ctrl.MuxHandler("preflight", handlePasswordAuthOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/login", ctrl.MuxHandler("preflight", handlePasswordAuthOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/register", ctrl.MuxHandler("preflight", handlePasswordAuthOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/remove-password", ctrl.MuxHandler("preflight", handlePasswordAuthOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/reset-password", ctrl.MuxHandler("preflight", handlePasswordAuthOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewChangePasswordPasswordAuthContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*ChangePasswordParams)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.ChangePassword(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handlePasswordAuthOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/change-password", ctrl.MuxHandler("change-password", h, unmarshalChangePasswordPasswordAuthPayload))
	service.LogInfo("mount", "ctrl", "PasswordAuth", "action", "ChangePassword", "route", "POST /api/v1/user/auth/change-password", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewConfirmResetPasswordAuthContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*ResetPasswordParams)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.ConfirmReset(rctx)
	}
	h = handleSecurity("key", h)
	h = handlePasswordAuthOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/finalize-reset", ctrl.MuxHandler("confirm-reset", h, unmarshalConfirmResetPasswordAuthPayload))
	service.LogInfo("mount", "ctrl", "PasswordAuth", "action", "ConfirmReset", "route", "POST /api/v1/user/auth/finalize-reset", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewLoginPasswordAuthContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*LoginParams)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Login(rctx)
	}
	h = handleSecurity("key", h)
	h = handlePasswordAuthOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/login", ctrl.MuxHandler("login", h, unmarshalLoginPasswordAuthPayload))
	service.LogInfo("mount", "ctrl", "PasswordAuth", "action", "Login", "route", "POST /api/v1/user/auth/login", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewRegisterPasswordAuthContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*RegisterParams)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Register(rctx)
	}
	h = handleSecurity("key", h)
	h = handlePasswordAuthOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/register", ctrl.MuxHandler("register", h, unmarshalRegisterPasswordAuthPayload))
	service.LogInfo("mount", "ctrl", "PasswordAuth", "action", "Register", "route", "POST /api/v1/user/auth/register", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewRemovePasswordAuthContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Remove(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handlePasswordAuthOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/remove-password", ctrl.MuxHandler("remove", h, nil))
	service.LogInfo("mount", "ctrl", "PasswordAuth", "action", "Remove", "route", "POST /api/v1/user/auth/remove-password", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewResetPasswordAuthContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Reset(rctx)
	}
	h = handleSecurity("key", h)
	h = handlePasswordAuthOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/reset-password", ctrl.MuxHandler("reset", h, nil))
	service.LogInfo("mount", "ctrl", "PasswordAuth", "action", "Reset", "route", "POST /api/v1/user/auth/reset-password", "security", "key")
}

// handlePasswordAuthOrigin applies the CORS response headers corresponding to the origin.
func handlePasswordAuthOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, PATCH, DELETE, OPTIONS")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalChangePasswordPasswordAuthPayload unmarshals the request body into the context request data Payload field.
func unmarshalChangePasswordPasswordAuthPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &changePasswordParams{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// unmarshalConfirmResetPasswordAuthPayload unmarshals the request body into the context request data Payload field.
func unmarshalConfirmResetPasswordAuthPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &resetPasswordParams{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// unmarshalLoginPasswordAuthPayload unmarshals the request body into the context request data Payload field.
func unmarshalLoginPasswordAuthPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &loginParams{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// unmarshalRegisterPasswordAuthPayload unmarshals the request body into the context request data Payload field.
func unmarshalRegisterPasswordAuthPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &registerParams{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// SessionController is the controller interface for the Session actions.
type SessionController interface {
	goa.Muxer
	CleanLoginToken(*CleanLoginTokenSessionContext) error
	CleanMergeToken(*CleanMergeTokenSessionContext) error
	CleanSessions(*CleanSessionsSessionContext) error
	GetSessions(*GetSessionsSessionContext) error
	Logout(*LogoutSessionContext) error
	LogoutOther(*LogoutOtherSessionContext) error
	LogoutSpecific(*LogoutSpecificSessionContext) error
	RedeemToken(*RedeemTokenSessionContext) error
	Refresh(*RefreshSessionContext) error
}

// MountSessionController "mounts" a Session resource controller on the given service.
func MountSessionController(service *goa.Service, ctrl SessionController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/clean/token/login", ctrl.MuxHandler("preflight", handleSessionOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/clean/token/merge", ctrl.MuxHandler("preflight", handleSessionOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/clean/sessions", ctrl.MuxHandler("preflight", handleSessionOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/sessions", ctrl.MuxHandler("preflight", handleSessionOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/logout", ctrl.MuxHandler("preflight", handleSessionOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/logout/all", ctrl.MuxHandler("preflight", handleSessionOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/logout/:session-id", ctrl.MuxHandler("preflight", handleSessionOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/token", ctrl.MuxHandler("preflight", handleSessionOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/session", ctrl.MuxHandler("preflight", handleSessionOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewCleanLoginTokenSessionContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.CleanLoginToken(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleSessionOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/clean/token/login", ctrl.MuxHandler("clean-login-token", h, nil))
	service.LogInfo("mount", "ctrl", "Session", "action", "CleanLoginToken", "route", "GET /api/v1/user/auth/clean/token/login", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewCleanMergeTokenSessionContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.CleanMergeToken(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleSessionOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/clean/token/merge", ctrl.MuxHandler("clean-merge-token", h, nil))
	service.LogInfo("mount", "ctrl", "Session", "action", "CleanMergeToken", "route", "GET /api/v1/user/auth/clean/token/merge", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewCleanSessionsSessionContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.CleanSessions(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleSessionOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/clean/sessions", ctrl.MuxHandler("clean-sessions", h, nil))
	service.LogInfo("mount", "ctrl", "Session", "action", "CleanSessions", "route", "GET /api/v1/user/auth/clean/sessions", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewGetSessionsSessionContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.GetSessions(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleSessionOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/sessions", ctrl.MuxHandler("get-sessions", h, nil))
	service.LogInfo("mount", "ctrl", "Session", "action", "GetSessions", "route", "GET /api/v1/user/auth/sessions", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewLogoutSessionContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Logout(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleSessionOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/logout", ctrl.MuxHandler("logout", h, nil))
	service.LogInfo("mount", "ctrl", "Session", "action", "Logout", "route", "POST /api/v1/user/auth/logout", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewLogoutOtherSessionContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.LogoutOther(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleSessionOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/logout/all", ctrl.MuxHandler("logout-other", h, nil))
	service.LogInfo("mount", "ctrl", "Session", "action", "LogoutOther", "route", "POST /api/v1/user/auth/logout/all", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewLogoutSpecificSessionContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.LogoutSpecific(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleSessionOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/logout/:session-id", ctrl.MuxHandler("logout-specific", h, nil))
	service.LogInfo("mount", "ctrl", "Session", "action", "LogoutSpecific", "route", "POST /api/v1/user/auth/logout/:session-id", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewRedeemTokenSessionContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*RedeemTokenSessionPayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.RedeemToken(rctx)
	}
	h = handleSessionOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/token", ctrl.MuxHandler("redeemToken", h, unmarshalRedeemTokenSessionPayload))
	service.LogInfo("mount", "ctrl", "Session", "action", "RedeemToken", "route", "POST /api/v1/user/auth/token")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewRefreshSessionContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Refresh(rctx)
	}
	h = handleSessionOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/session", ctrl.MuxHandler("refresh", h, nil))
	service.LogInfo("mount", "ctrl", "Session", "action", "Refresh", "route", "POST /api/v1/user/auth/session")
}

// handleSessionOrigin applies the CORS response headers corresponding to the origin.
func handleSessionOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, PATCH, DELETE, OPTIONS")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalRedeemTokenSessionPayload unmarshals the request body into the context request data Payload field.
func unmarshalRedeemTokenSessionPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &redeemTokenSessionPayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// TwitterController is the controller interface for the Twitter actions.
type TwitterController interface {
	goa.Muxer
	AttachToAccount(*AttachToAccountTwitterContext) error
	DetachFromAccount(*DetachFromAccountTwitterContext) error
	Login(*LoginTwitterContext) error
	Receive(*ReceiveTwitterContext) error
	Register(*RegisterTwitterContext) error
	RegisterURL(*RegisterURLTwitterContext) error
}

// MountTwitterController "mounts" a Twitter resource controller on the given service.
func MountTwitterController(service *goa.Service, ctrl TwitterController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/twitter/attach", ctrl.MuxHandler("preflight", handleTwitterOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/twitter/detach", ctrl.MuxHandler("preflight", handleTwitterOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/twitter/login", ctrl.MuxHandler("preflight", handleTwitterOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/twitter/receive", ctrl.MuxHandler("preflight", handleTwitterOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/twitter/register", ctrl.MuxHandler("preflight", handleTwitterOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/auth/twitter/register-start", ctrl.MuxHandler("preflight", handleTwitterOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewAttachToAccountTwitterContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.AttachToAccount(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleTwitterOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/twitter/attach", ctrl.MuxHandler("attach-to-account", h, nil))
	service.LogInfo("mount", "ctrl", "Twitter", "action", "AttachToAccount", "route", "POST /api/v1/user/auth/twitter/attach", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewDetachFromAccountTwitterContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.DetachFromAccount(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleTwitterOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/twitter/detach", ctrl.MuxHandler("detach-from-account", h, nil))
	service.LogInfo("mount", "ctrl", "Twitter", "action", "DetachFromAccount", "route", "POST /api/v1/user/auth/twitter/detach", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewLoginTwitterContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Login(rctx)
	}
	h = handleSecurity("key", h)
	h = handleTwitterOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/twitter/login", ctrl.MuxHandler("login", h, nil))
	service.LogInfo("mount", "ctrl", "Twitter", "action", "Login", "route", "GET /api/v1/user/auth/twitter/login", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewReceiveTwitterContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Receive(rctx)
	}
	h = handleSecurity("key", h)
	h = handleTwitterOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/twitter/receive", ctrl.MuxHandler("receive", h, nil))
	service.LogInfo("mount", "ctrl", "Twitter", "action", "Receive", "route", "GET /api/v1/user/auth/twitter/receive", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewRegisterTwitterContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*TwitterRegisterParams)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Register(rctx)
	}
	h = handleSecurity("key", h)
	h = handleTwitterOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/auth/twitter/register", ctrl.MuxHandler("register", h, unmarshalRegisterTwitterPayload))
	service.LogInfo("mount", "ctrl", "Twitter", "action", "Register", "route", "POST /api/v1/user/auth/twitter/register", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewRegisterURLTwitterContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.RegisterURL(rctx)
	}
	h = handleSecurity("key", h)
	h = handleTwitterOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/auth/twitter/register-start", ctrl.MuxHandler("register-url", h, nil))
	service.LogInfo("mount", "ctrl", "Twitter", "action", "RegisterURL", "route", "GET /api/v1/user/auth/twitter/register-start", "security", "key")
}

// handleTwitterOrigin applies the CORS response headers corresponding to the origin.
func handleTwitterOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, PATCH, DELETE, OPTIONS")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalRegisterTwitterPayload unmarshals the request body into the context request data Payload field.
func unmarshalRegisterTwitterPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &twitterRegisterParams{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// UserController is the controller interface for the User actions.
type UserController interface {
	goa.Muxer
	AddPlugin(*AddPluginUserContext) error
	Deactivate(*DeactivateUserContext) error
	GetAllUsers(*GetAllUsersUserContext) error
	GetByEmail(*GetByEmailUserContext) error
	GetMany(*GetManyUserContext) error
	GetAuths(*GetAuthsUserContext) error
	ResendVerifyEmail(*ResendVerifyEmailUserContext) error
	Retrieve(*RetrieveUserContext) error
	Update(*UpdateUserContext) error
	UpdateAdmin(*UpdateAdminUserContext) error
	UpdatePluginPermissions(*UpdatePluginPermissionsUserContext) error
	ValidateEmail(*ValidateEmailUserContext) error
}

// MountUserController "mounts" a User resource controller on the given service.
func MountUserController(service *goa.Service, ctrl UserController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/api/v1/user/user/plugins", ctrl.MuxHandler("preflight", handleUserOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/user", ctrl.MuxHandler("preflight", handleUserOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/user/all", ctrl.MuxHandler("preflight", handleUserOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/user/email", ctrl.MuxHandler("preflight", handleUserOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/user/multi", ctrl.MuxHandler("preflight", handleUserOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/user/authstat", ctrl.MuxHandler("preflight", handleUserOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/user/resend-verify", ctrl.MuxHandler("preflight", handleUserOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/api/v1/user/user/update-user", ctrl.MuxHandler("preflight", handleUserOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/verifyemail/:validateID", ctrl.MuxHandler("preflight", handleUserOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewAddPluginUserContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*UserPlugin)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.AddPlugin(rctx)
	}
	h = handleSecurity("key", h)
	h = handleUserOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/user/plugins", ctrl.MuxHandler("add-plugin", h, unmarshalAddPluginUserPayload))
	service.LogInfo("mount", "ctrl", "User", "action", "AddPlugin", "route", "POST /api/v1/user/user/plugins", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewDeactivateUserContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Deactivate(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleUserOrigin(h)
	service.Mux.Handle("DELETE", "/api/v1/user/user", ctrl.MuxHandler("deactivate", h, nil))
	service.LogInfo("mount", "ctrl", "User", "action", "Deactivate", "route", "DELETE /api/v1/user/user", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewGetAllUsersUserContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.GetAllUsers(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleUserOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/user/all", ctrl.MuxHandler("get-all-users", h, nil))
	service.LogInfo("mount", "ctrl", "User", "action", "GetAllUsers", "route", "GET /api/v1/user/user/all", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewGetByEmailUserContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.GetByEmail(rctx)
	}
	h = handleSecurity("key", h)
	h = handleUserOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/user/email", ctrl.MuxHandler("get-by-email", h, nil))
	service.LogInfo("mount", "ctrl", "User", "action", "GetByEmail", "route", "GET /api/v1/user/user/email", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewGetManyUserContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.GetMany(rctx)
	}
	h = handleSecurity("key", h)
	h = handleUserOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/user/multi", ctrl.MuxHandler("get-many", h, nil))
	service.LogInfo("mount", "ctrl", "User", "action", "GetMany", "route", "GET /api/v1/user/user/multi", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewGetAuthsUserContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.GetAuths(rctx)
	}
	h = handleSecurity("key", h)
	h = handleUserOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/user/authstat", ctrl.MuxHandler("getAuths", h, nil))
	service.LogInfo("mount", "ctrl", "User", "action", "GetAuths", "route", "GET /api/v1/user/user/authstat", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewResendVerifyEmailUserContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.ResendVerifyEmail(rctx)
	}
	h = handleSecurity("key", h)
	h = handleUserOrigin(h)
	service.Mux.Handle("POST", "/api/v1/user/user/resend-verify", ctrl.MuxHandler("resend-verify-email", h, nil))
	service.LogInfo("mount", "ctrl", "User", "action", "ResendVerifyEmail", "route", "POST /api/v1/user/user/resend-verify", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewRetrieveUserContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Retrieve(rctx)
	}
	h = handleSecurity("key", h)
	h = handleUserOrigin(h)
	service.Mux.Handle("GET", "/api/v1/user/user", ctrl.MuxHandler("retrieve", h, nil))
	service.LogInfo("mount", "ctrl", "User", "action", "Retrieve", "route", "GET /api/v1/user/user", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewUpdateUserContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*UserParams)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Update(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleUserOrigin(h)
	service.Mux.Handle("PATCH", "/api/v1/user/user", ctrl.MuxHandler("update", h, unmarshalUpdateUserPayload))
	service.LogInfo("mount", "ctrl", "User", "action", "Update", "route", "PATCH /api/v1/user/user", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewUpdateAdminUserContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*UserParamsAdmin)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.UpdateAdmin(rctx)
	}
	h = handleSecurity("jwt", h)
	h = handleUserOrigin(h)
	service.Mux.Handle("PATCH", "/api/v1/user/user/update-user", ctrl.MuxHandler("update-admin", h, unmarshalUpdateAdminUserPayload))
	service.LogInfo("mount", "ctrl", "User", "action", "UpdateAdmin", "route", "PATCH /api/v1/user/user/update-user", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewUpdatePluginPermissionsUserContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*UserPlugin)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.UpdatePluginPermissions(rctx)
	}
	h = handleSecurity("key", h)
	h = handleUserOrigin(h)
	service.Mux.Handle("PUT", "/api/v1/user/user/plugins", ctrl.MuxHandler("update-plugin-permissions", h, unmarshalUpdatePluginPermissionsUserPayload))
	service.LogInfo("mount", "ctrl", "User", "action", "UpdatePluginPermissions", "route", "PUT /api/v1/user/user/plugins", "security", "key")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewValidateEmailUserContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.ValidateEmail(rctx)
	}
	h = handleSecurity("key", h)
	h = handleUserOrigin(h)
	service.Mux.Handle("GET", "/verifyemail/:validateID", ctrl.MuxHandler("validate-email", h, nil))
	service.LogInfo("mount", "ctrl", "User", "action", "ValidateEmail", "route", "GET /verifyemail/:validateID", "security", "key")
}

// handleUserOrigin applies the CORS response headers corresponding to the origin.
func handleUserOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, PATCH, DELETE, OPTIONS")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalAddPluginUserPayload unmarshals the request body into the context request data Payload field.
func unmarshalAddPluginUserPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &userPlugin{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// unmarshalUpdateUserPayload unmarshals the request body into the context request data Payload field.
func unmarshalUpdateUserPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &userParams{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// unmarshalUpdateAdminUserPayload unmarshals the request body into the context request data Payload field.
func unmarshalUpdateAdminUserPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &userParamsAdmin{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// unmarshalUpdatePluginPermissionsUserPayload unmarshals the request body into the context request data Payload field.
func unmarshalUpdatePluginPermissionsUserPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &userPlugin{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}
